        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits
        -:    0:Graph:TestCollatz.gcno
        -:    0:Data:TestCollatz.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===------------------------ type_traits ---------------------------------===//
        -:    3://
        -:    4://                     The LLVM Compiler Infrastructure
        -:    5://
        -:    6:// This file is dual licensed under the MIT and the University of Illinois Open
        -:    7:// Source Licenses. See LICENSE.TXT for details.
        -:    8://
        -:    9://===----------------------------------------------------------------------===//
        -:   10:
        -:   11:#ifndef _LIBCPP_TYPE_TRAITS
        -:   12:#define _LIBCPP_TYPE_TRAITS
        -:   13:
        -:   14:/*
        -:   15:    type_traits synopsis
        -:   16:
        -:   17:namespace std
        -:   18:{
        -:   19:
        -:   20:    // helper class:
        -:   21:    template <class T, T v> struct integral_constant;
        -:   22:    typedef integral_constant<bool, true>  true_type;
        -:   23:    typedef integral_constant<bool, false> false_type;
        -:   24:
        -:   25:    // helper traits
        -:   26:    template <bool, class T = void> struct enable_if;
        -:   27:    template <bool, class T, class F> struct conditional;
        -:   28:
        -:   29:    // Primary classification traits:
        -:   30:    template <class T> struct is_void;
        -:   31:    template <class T> struct is_null_pointer;  // C++14
        -:   32:    template <class T> struct is_integral;
        -:   33:    template <class T> struct is_floating_point;
        -:   34:    template <class T> struct is_array;
        -:   35:    template <class T> struct is_pointer;
        -:   36:    template <class T> struct is_lvalue_reference;
        -:   37:    template <class T> struct is_rvalue_reference;
        -:   38:    template <class T> struct is_member_object_pointer;
        -:   39:    template <class T> struct is_member_function_pointer;
        -:   40:    template <class T> struct is_enum;
        -:   41:    template <class T> struct is_union;
        -:   42:    template <class T> struct is_class;
        -:   43:    template <class T> struct is_function;
        -:   44:
        -:   45:    // Secondary classification traits:
        -:   46:    template <class T> struct is_reference;
        -:   47:    template <class T> struct is_arithmetic;
        -:   48:    template <class T> struct is_fundamental;
        -:   49:    template <class T> struct is_member_pointer;
        -:   50:    template <class T> struct is_scalar;
        -:   51:    template <class T> struct is_object;
        -:   52:    template <class T> struct is_compound;
        -:   53:
        -:   54:    // Const-volatile properties and transformations:
        -:   55:    template <class T> struct is_const;
        -:   56:    template <class T> struct is_volatile;
        -:   57:    template <class T> struct remove_const;
        -:   58:    template <class T> struct remove_volatile;
        -:   59:    template <class T> struct remove_cv;
        -:   60:    template <class T> struct add_const;
        -:   61:    template <class T> struct add_volatile;
        -:   62:    template <class T> struct add_cv;
        -:   63:
        -:   64:    // Reference transformations:
        -:   65:    template <class T> struct remove_reference;
        -:   66:    template <class T> struct add_lvalue_reference;
        -:   67:    template <class T> struct add_rvalue_reference;
        -:   68:
        -:   69:    // Pointer transformations:
        -:   70:    template <class T> struct remove_pointer;
        -:   71:    template <class T> struct add_pointer;
        -:   72:
        -:   73:    // Integral properties:
        -:   74:    template <class T> struct is_signed;
        -:   75:    template <class T> struct is_unsigned;
        -:   76:    template <class T> struct make_signed;
        -:   77:    template <class T> struct make_unsigned;
        -:   78:
        -:   79:    // Array properties and transformations:
        -:   80:    template <class T> struct rank;
        -:   81:    template <class T, unsigned I = 0> struct extent;
        -:   82:    template <class T> struct remove_extent;
        -:   83:    template <class T> struct remove_all_extents;
        -:   84:
        -:   85:    // Member introspection:
        -:   86:    template <class T> struct is_pod;
        -:   87:    template <class T> struct is_trivial;
        -:   88:    template <class T> struct is_trivially_copyable;
        -:   89:    template <class T> struct is_standard_layout;
        -:   90:    template <class T> struct is_literal_type;
        -:   91:    template <class T> struct is_empty;
        -:   92:    template <class T> struct is_polymorphic;
        -:   93:    template <class T> struct is_abstract;
        -:   94:    template <class T> struct is_final; // C++14
        -:   95:
        -:   96:    template <class T, class... Args> struct is_constructible;
        -:   97:    template <class T>                struct is_default_constructible;
        -:   98:    template <class T>                struct is_copy_constructible;
        -:   99:    template <class T>                struct is_move_constructible;
        -:  100:    template <class T, class U>       struct is_assignable;
        -:  101:    template <class T>                struct is_copy_assignable;
        -:  102:    template <class T>                struct is_move_assignable;
        -:  103:    template <class T>                struct is_destructible;
        -:  104:
        -:  105:    template <class T, class... Args> struct is_trivially_constructible;
        -:  106:    template <class T>                struct is_trivially_default_constructible;
        -:  107:    template <class T>                struct is_trivially_copy_constructible;
        -:  108:    template <class T>                struct is_trivially_move_constructible;
        -:  109:    template <class T, class U>       struct is_trivially_assignable;
        -:  110:    template <class T>                struct is_trivially_copy_assignable;
        -:  111:    template <class T>                struct is_trivially_move_assignable;
        -:  112:    template <class T>                struct is_trivially_destructible;
        -:  113:
        -:  114:    template <class T, class... Args> struct is_nothrow_constructible;
        -:  115:    template <class T>                struct is_nothrow_default_constructible;
        -:  116:    template <class T>                struct is_nothrow_copy_constructible;
        -:  117:    template <class T>                struct is_nothrow_move_constructible;
        -:  118:    template <class T, class U>       struct is_nothrow_assignable;
        -:  119:    template <class T>                struct is_nothrow_copy_assignable;
        -:  120:    template <class T>                struct is_nothrow_move_assignable;
        -:  121:    template <class T>                struct is_nothrow_destructible;
        -:  122:
        -:  123:    template <class T> struct has_virtual_destructor;
        -:  124:
        -:  125:    // Relationships between types:
        -:  126:    template <class T, class U> struct is_same;
        -:  127:    template <class Base, class Derived> struct is_base_of;
        -:  128:    template <class From, class To> struct is_convertible;
        -:  129:
        -:  130:    // Alignment properties and transformations:
        -:  131:    template <class T> struct alignment_of;
        -:  132:    template <size_t Len, size_t Align = most_stringent_alignment_requirement>
        -:  133:        struct aligned_storage;
        -:  134:    template <size_t Len, class... Types> struct aligned_union;
        -:  135:
        -:  136:    template <class T> struct decay;
        -:  137:    template <class... T> struct common_type;
        -:  138:    template <class T> struct underlying_type;
        -:  139:    template <class> class result_of; // undefined
        -:  140:    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;
        -:  141:
        -:  142:    // const-volatile modifications:
        -:  143:    template <class T>
        -:  144:      using remove_const_t    = typename remove_const<T>::type;  // C++14
        -:  145:    template <class T>
        -:  146:      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14
        -:  147:    template <class T>
        -:  148:      using remove_cv_t       = typename remove_cv<T>::type;  // C++14
        -:  149:    template <class T>
        -:  150:      using add_const_t       = typename add_const<T>::type;  // C++14
        -:  151:    template <class T>
        -:  152:      using add_volatile_t    = typename add_volatile<T>::type;  // C++14
        -:  153:    template <class T>
        -:  154:      using add_cv_t          = typename add_cv<T>::type;  // C++14
        -:  155:  
        -:  156:    // reference modifications:
        -:  157:    template <class T>
        -:  158:      using remove_reference_t     = typename remove_reference<T>::type;  // C++14
        -:  159:    template <class T>
        -:  160:      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14
        -:  161:    template <class T>
        -:  162:      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14
        -:  163:  
        -:  164:    // sign modifications:
        -:  165:    template <class T>
        -:  166:      using make_signed_t   = typename make_signed<T>::type;  // C++14
        -:  167:    template <class T>
        -:  168:      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14
        -:  169:  
        -:  170:    // array modifications:
        -:  171:    template <class T>
        -:  172:      using remove_extent_t      = typename remove_extent<T>::type;  // C++14
        -:  173:    template <class T>
        -:  174:      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14
        -:  175:
        -:  176:    // pointer modifications:
        -:  177:    template <class T>
        -:  178:      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14
        -:  179:    template <class T>
        -:  180:      using add_pointer_t    = typename add_pointer<T>::type;  // C++14
        -:  181:
        -:  182:    // other transformations:
        -:  183:    template <size_t Len, std::size_t Align=default-alignment>
        -:  184:      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14
        -:  185:    template <std::size_t Len, class... Types>
        -:  186:      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14
        -:  187:    template <class T>
        -:  188:      using decay_t           = typename decay<T>::type;  // C++14
        -:  189:    template <bool b, class T=void>
        -:  190:      using enable_if_t       = typename enable_if<b,T>::type;  // C++14
        -:  191:    template <bool b, class T, class F>
        -:  192:      using conditional_t     = typename conditional<b,T,F>::type;  // C++14
        -:  193:    template <class... T>
        -:  194:      using common_type_t     = typename common_type<T...>::type;  // C++14
        -:  195:    template <class T>
        -:  196:      using underlying_type_t = typename underlying_type<T>::type;  // C++14
        -:  197:    template <class F, class... ArgTypes>
        -:  198:      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14
        -:  199:
        -:  200:}  // std
        -:  201:
        -:  202:*/
        -:  203:#include <__config>
        -:  204:#include <cstddef>
        -:  205:
        -:  206:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  207:#pragma GCC system_header
        -:  208:#endif
        -:  209:
        -:  210:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  211:
        -:  212:template <bool _Bp, class _If, class _Then>
        -:  213:    struct _LIBCPP_TYPE_VIS_ONLY conditional {typedef _If type;};
        -:  214:template <class _If, class _Then>
        -:  215:    struct _LIBCPP_TYPE_VIS_ONLY conditional<false, _If, _Then> {typedef _Then type;};
        -:  216:
        -:  217:#if _LIBCPP_STD_VER > 11
        -:  218:template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;
        -:  219:#endif
        -:  220:
        -:  221:template <bool, class _Tp = void> struct _LIBCPP_TYPE_VIS_ONLY enable_if {};
        -:  222:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY enable_if<true, _Tp> {typedef _Tp type;};
        -:  223:
        -:  224:#if _LIBCPP_STD_VER > 11
        -:  225:template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;
        -:  226:#endif
        -:  227:
        -:  228:
        -:  229:struct __two {char __lx[2];};
        -:  230:
        -:  231:// helper class:
        -:  232:
        -:  233:template <class _Tp, _Tp __v>
        -:  234:struct _LIBCPP_TYPE_VIS_ONLY integral_constant
        -:  235:{
        -:  236:    static _LIBCPP_CONSTEXPR const _Tp      value = __v;
        -:  237:    typedef _Tp               value_type;
        -:  238:    typedef integral_constant type;
        -:  239:    _LIBCPP_INLINE_VISIBILITY
        -:  240:        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}
        -:  241:#if _LIBCPP_STD_VER > 11
        -:  242:    _LIBCPP_INLINE_VISIBILITY
        -:  243:         constexpr value_type operator ()() const _NOEXCEPT {return value;}
        -:  244:#endif
        -:  245:};
        -:  246:
        -:  247:template <class _Tp, _Tp __v>
        -:  248:_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;
        -:  249:
        -:  250:typedef integral_constant<bool, true>  true_type;
        -:  251:typedef integral_constant<bool, false> false_type;
        -:  252:
        -:  253:// is_const
        -:  254:
        -:  255:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const            : public false_type {};
        -:  256:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const<_Tp const> : public true_type {};
        -:  257:
        -:  258:// is_volatile
        -:  259:
        -:  260:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile               : public false_type {};
        -:  261:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile<_Tp volatile> : public true_type {};
        -:  262:
        -:  263:// remove_const
        -:  264:
        -:  265:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const            {typedef _Tp type;};
        -:  266:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const<const _Tp> {typedef _Tp type;};
        -:  267:#if _LIBCPP_STD_VER > 11
        -:  268:template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;
        -:  269:#endif
        -:  270:
        -:  271:// remove_volatile
        -:  272:
        -:  273:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile               {typedef _Tp type;};
        -:  274:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile<volatile _Tp> {typedef _Tp type;};
        -:  275:#if _LIBCPP_STD_VER > 11
        -:  276:template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
        -:  277:#endif
        -:  278:
        -:  279:// remove_cv
        -:  280:
        -:  281:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_cv
        -:  282:{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};
        -:  283:#if _LIBCPP_STD_VER > 11
        -:  284:template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
        -:  285:#endif
        -:  286:
        -:  287:// is_void
        -:  288:
        -:  289:template <class _Tp> struct __libcpp_is_void       : public false_type {};
        -:  290:template <>          struct __libcpp_is_void<void> : public true_type {};
        -:  291:
        -:  292:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_void
        -:  293:    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};
        -:  294:
        -:  295:// __is_nullptr_t
        -:  296:
        -:  297:template <class _Tp> struct __is_nullptr_t_impl       : public false_type {};
        -:  298:template <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};
        -:  299:
        -:  300:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __is_nullptr_t
        -:  301:    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
        -:  302:
        -:  303:#if _LIBCPP_STD_VER > 11
        -:  304:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_null_pointer
        -:  305:    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
        -:  306:#endif
        -:  307:
        -:  308:// is_integral
        -:  309:
        -:  310:template <class _Tp> struct __libcpp_is_integral                     : public false_type {};
        -:  311:template <>          struct __libcpp_is_integral<bool>               : public true_type {};
        -:  312:template <>          struct __libcpp_is_integral<char>               : public true_type {};
        -:  313:template <>          struct __libcpp_is_integral<signed char>        : public true_type {};
        -:  314:template <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};
        -:  315:template <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};
        -:  316:#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
        -:  317:template <>          struct __libcpp_is_integral<char16_t>           : public true_type {};
        -:  318:template <>          struct __libcpp_is_integral<char32_t>           : public true_type {};
        -:  319:#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
        -:  320:template <>          struct __libcpp_is_integral<short>              : public true_type {};
        -:  321:template <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};
        -:  322:template <>          struct __libcpp_is_integral<int>                : public true_type {};
        -:  323:template <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};
        -:  324:template <>          struct __libcpp_is_integral<long>               : public true_type {};
        -:  325:template <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};
        -:  326:template <>          struct __libcpp_is_integral<long long>          : public true_type {};
        -:  327:template <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};
        -:  328:#ifndef _LIBCPP_HAS_NO_INT128
        -:  329:template <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};
        -:  330:template <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};
        -:  331:#endif
        -:  332:
        -:  333:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_integral
        -:  334:    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};
        -:  335:
        -:  336:// is_floating_point
        -:  337:
        -:  338:template <class _Tp> struct __libcpp_is_floating_point              : public false_type {};
        -:  339:template <>          struct __libcpp_is_floating_point<float>       : public true_type {};
        -:  340:template <>          struct __libcpp_is_floating_point<double>      : public true_type {};
        -:  341:template <>          struct __libcpp_is_floating_point<long double> : public true_type {};
        -:  342:
        -:  343:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point
        -:  344:    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
        -:  345:
        -:  346:// is_array
        -:  347:
        -:  348:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array
        -:  349:    : public false_type {};
        -:  350:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[]>
        -:  351:    : public true_type {};
        -:  352:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[_Np]>
        -:  353:    : public true_type {};
        -:  354:
        -:  355:// is_pointer
        -:  356:
        -:  357:template <class _Tp> struct __libcpp_is_pointer       : public false_type {};
        -:  358:template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};
        -:  359:
        -:  360:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pointer
        -:  361:    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};
        -:  362:
        -:  363:// is_reference
        -:  364:
        -:  365:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference       : public false_type {};
        -:  366:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference<_Tp&> : public true_type {};
        -:  367:
        -:  368:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference        : public false_type {};
        -:  369:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  370:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference<_Tp&&> : public true_type {};
        -:  371:#endif
        -:  372:
        -:  373:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference        : public false_type {};
        -:  374:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&>  : public true_type {};
        -:  375:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  376:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&&> : public true_type {};
        -:  377:#endif
        -:  378:
        -:  379:// is_union
        -:  380:
        -:  381:#if __has_feature(is_union) || (_GNUC_VER >= 403)
        -:  382:
        -:  383:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union
        -:  384:    : public integral_constant<bool, __is_union(_Tp)> {};
        -:  385:
        -:  386:#else
        -:  387:
        -:  388:template <class _Tp> struct __libcpp_union : public false_type {};
        -:  389:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union
        -:  390:    : public __libcpp_union<typename remove_cv<_Tp>::type> {};
        -:  391:
        -:  392:#endif
        -:  393:
        -:  394:// is_class
        -:  395:
        -:  396:#if __has_feature(is_class) || (_GNUC_VER >= 403)
        -:  397:
        -:  398:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class
        -:  399:    : public integral_constant<bool, __is_class(_Tp)> {};
        -:  400:
        -:  401:#else
        -:  402:
        -:  403:namespace __is_class_imp
        -:  404:{
        -:  405:template <class _Tp> char  __test(int _Tp::*);
        -:  406:template <class _Tp> __two __test(...);
        -:  407:}
        -:  408:
        -:  409:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class
        -:  410:    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};
        -:  411:
        -:  412:#endif
        -:  413:
        -:  414:// is_same
        -:  415:
        -:  416:template <class _Tp, class _Up> struct _LIBCPP_TYPE_VIS_ONLY is_same           : public false_type {};
        -:  417:template <class _Tp>            struct _LIBCPP_TYPE_VIS_ONLY is_same<_Tp, _Tp> : public true_type {};
        -:  418:
        -:  419:// is_function
        -:  420:
        -:  421:namespace __libcpp_is_function_imp
        -:  422:{
        -:  423:template <class _Tp> char  __test(_Tp*);
        -:  424:template <class _Tp> __two __test(...);
        -:  425:template <class _Tp> _Tp&  __source();
        -:  426:}
        -:  427:
        -:  428:template <class _Tp, bool = is_class<_Tp>::value ||
        -:  429:                            is_union<_Tp>::value ||
        -:  430:                            is_void<_Tp>::value  ||
        -:  431:                            is_reference<_Tp>::value ||
        -:  432:                            __is_nullptr_t<_Tp>::value >
        -:  433:struct __libcpp_is_function
        -:  434:    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>())) == 1>
        -:  435:    {};
        -:  436:template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};
        -:  437:
        -:  438:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_function
        -:  439:    : public __libcpp_is_function<_Tp> {};
        -:  440:
        -:  441:// is_member_function_pointer
        -:  442:
        -:  443:// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};
        -:  444:// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};
        -:  445:// 
        -:  446:
        -:  447:template <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>
        -:  448:struct __member_pointer_traits_imp
        -:  449:{  // forward declaration; specializations later
        -:  450:};
        -:  451:
        -:  452:
        -:  453:namespace __libcpp_is_member_function_pointer_imp {
        -:  454:    template <typename _Tp>
        -:  455:    char __test(typename std::__member_pointer_traits_imp<_Tp, true, false>::_FnType *);
        -:  456:
        -:  457:    template <typename>
        -:  458:    std::__two __test(...);
        -:  459:};
        -:  460:    
        -:  461:template <class _Tp> struct __libcpp_is_member_function_pointer
        -:  462:    : public integral_constant<bool, sizeof(__libcpp_is_member_function_pointer_imp::__test<_Tp>(nullptr)) == 1> {};
        -:  463:
        -:  464:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_function_pointer
        -:  465:    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type> {};
        -:  466:
        -:  467:// is_member_pointer
        -:  468:
        -:  469:template <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};
        -:  470:template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};
        -:  471:
        -:  472:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_pointer
        -:  473:    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};
        -:  474:
        -:  475:// is_member_object_pointer
        -:  476:
        -:  477:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_object_pointer
        -:  478:    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
        -:  479:                                    !is_member_function_pointer<_Tp>::value> {};
        -:  480:
        -:  481:// is_enum
        -:  482:
        -:  483:#if __has_feature(is_enum) || (_GNUC_VER >= 403)
        -:  484:
        -:  485:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum
        -:  486:    : public integral_constant<bool, __is_enum(_Tp)> {};
        -:  487:
        -:  488:#else
        -:  489:
        -:  490:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum
        -:  491:    : public integral_constant<bool, !is_void<_Tp>::value             &&
        -:  492:                                     !is_integral<_Tp>::value         &&
        -:  493:                                     !is_floating_point<_Tp>::value   &&
        -:  494:                                     !is_array<_Tp>::value            &&
        -:  495:                                     !is_pointer<_Tp>::value          &&
        -:  496:                                     !is_reference<_Tp>::value        &&
        -:  497:                                     !is_member_pointer<_Tp>::value   &&
        -:  498:                                     !is_union<_Tp>::value            &&
        -:  499:                                     !is_class<_Tp>::value            &&
        -:  500:                                     !is_function<_Tp>::value         > {};
        -:  501:
        -:  502:#endif
        -:  503:
        -:  504:// is_arithmetic
        -:  505:
        -:  506:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_arithmetic
        -:  507:    : public integral_constant<bool, is_integral<_Tp>::value      ||
        -:  508:                                     is_floating_point<_Tp>::value> {};
        -:  509:
        -:  510:// is_fundamental
        -:  511:
        -:  512:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_fundamental
        -:  513:    : public integral_constant<bool, is_void<_Tp>::value        ||
        -:  514:                                     __is_nullptr_t<_Tp>::value ||
        -:  515:                                     is_arithmetic<_Tp>::value> {};
        -:  516:
        -:  517:// is_scalar
        -:  518:
        -:  519:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_scalar
        -:  520:    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||
        -:  521:                                     is_member_pointer<_Tp>::value ||
        -:  522:                                     is_pointer<_Tp>::value        ||
        -:  523:                                     __is_nullptr_t<_Tp>::value    ||
        -:  524:                                     is_enum<_Tp>::value           > {};
        -:  525:
        -:  526:template <> struct _LIBCPP_TYPE_VIS_ONLY is_scalar<nullptr_t> : public true_type {};
        -:  527:
        -:  528:// is_object
        -:  529:
        -:  530:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_object
        -:  531:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -:  532:                                     is_array<_Tp>::value  ||
        -:  533:                                     is_union<_Tp>::value  ||
        -:  534:                                     is_class<_Tp>::value  > {};
        -:  535:
        -:  536:// is_compound
        -:  537:
        -:  538:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_compound
        -:  539:    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
        -:  540:
        -:  541:// add_const
        -:  542:
        -:  543:template <class _Tp, bool = is_reference<_Tp>::value ||
        -:  544:                            is_function<_Tp>::value  ||
        -:  545:                            is_const<_Tp>::value     >
        -:  546:struct __add_const             {typedef _Tp type;};
        -:  547:
        -:  548:template <class _Tp>
        -:  549:struct __add_const<_Tp, false> {typedef const _Tp type;};
        -:  550:
        -:  551:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_const
        -:  552:    {typedef typename __add_const<_Tp>::type type;};
        -:  553:
        -:  554:#if _LIBCPP_STD_VER > 11
        -:  555:template <class _Tp> using add_const_t = typename add_const<_Tp>::type;
        -:  556:#endif
        -:  557:
        -:  558:// add_volatile
        -:  559:
        -:  560:template <class _Tp, bool = is_reference<_Tp>::value ||
        -:  561:                            is_function<_Tp>::value  ||
        -:  562:                            is_volatile<_Tp>::value  >
        -:  563:struct __add_volatile             {typedef _Tp type;};
        -:  564:
        -:  565:template <class _Tp>
        -:  566:struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};
        -:  567:
        -:  568:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_volatile
        -:  569:    {typedef typename __add_volatile<_Tp>::type type;};
        -:  570:
        -:  571:#if _LIBCPP_STD_VER > 11
        -:  572:template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
        -:  573:#endif
        -:  574:
        -:  575:// add_cv
        -:  576:
        -:  577:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_cv
        -:  578:    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};
        -:  579:
        -:  580:#if _LIBCPP_STD_VER > 11
        -:  581:template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;
        -:  582:#endif
        -:  583:
        -:  584:// remove_reference
        -:  585:
        -:  586:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference        {typedef _Tp type;};
        -:  587:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&>  {typedef _Tp type;};
        -:  588:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  589:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&&> {typedef _Tp type;};
        -:  590:#endif
        -:  591:
        -:  592:#if _LIBCPP_STD_VER > 11
        -:  593:template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
        -:  594:#endif
        -:  595:
        -:  596:// add_lvalue_reference
        -:  597:
        -:  598:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference                      {typedef _Tp& type;};
        -:  599:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<_Tp&>                {typedef _Tp& type;};  // for older compiler
        -:  600:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<void>                {typedef void type;};
        -:  601:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const void>          {typedef const void type;};
        -:  602:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<volatile void>       {typedef volatile void type;};
        -:  603:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const volatile void> {typedef const volatile void type;};
        -:  604:
        -:  605:#if _LIBCPP_STD_VER > 11
        -:  606:template <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
        -:  607:#endif
        -:  608:
        -:  609:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  610:
        -:  611:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY  add_rvalue_reference                     {typedef _Tp&& type;};
        -:  612:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<void>                {typedef void type;};
        -:  613:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const void>          {typedef const void type;};
        -:  614:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<volatile void>       {typedef volatile void type;};
        -:  615:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const volatile void> {typedef const volatile void type;};
        -:  616:
        -:  617:#if _LIBCPP_STD_VER > 11
        -:  618:template <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
        -:  619:#endif
        -:  620:
        -:  621:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  622:
        -:  623:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  624:
        -:  625:template <class _Tp>
        -:  626:typename add_rvalue_reference<_Tp>::type
        -:  627:declval() _NOEXCEPT;
        -:  628:
        -:  629:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  630:
        -:  631:template <class _Tp>
        -:  632:typename add_lvalue_reference<_Tp>::type
        -:  633:declval();
        -:  634:
        -:  635:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  636:
        -:  637:struct __any
        -:  638:{
        -:  639:    __any(...);
        -:  640:};
        -:  641:
        -:  642:// remove_pointer
        -:  643:
        -:  644:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer                      {typedef _Tp type;};
        -:  645:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp*>                {typedef _Tp type;};
        -:  646:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const>          {typedef _Tp type;};
        -:  647:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* volatile>       {typedef _Tp type;};
        -:  648:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const volatile> {typedef _Tp type;};
        -:  649:
        -:  650:#if _LIBCPP_STD_VER > 11
        -:  651:template <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;
        -:  652:#endif
        -:  653:
        -:  654:// add_pointer
        -:  655:
        -:  656:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_pointer
        -:  657:    {typedef typename remove_reference<_Tp>::type* type;};
        -:  658:
        -:  659:#if _LIBCPP_STD_VER > 11
        -:  660:template <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
        -:  661:#endif
        -:  662:
        -:  663:// is_signed
        -:  664:
        -:  665:template <class _Tp, bool = is_integral<_Tp>::value>
        -:  666:struct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};
        -:  667:
        -:  668:template <class _Tp>
        -:  669:struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point
        -:  670:
        -:  671:template <class _Tp, bool = is_arithmetic<_Tp>::value>
        -:  672:struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};
        -:  673:
        -:  674:template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};
        -:  675:
        -:  676:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_signed : public __libcpp_is_signed<_Tp> {};
        -:  677:
        -:  678:// is_unsigned
        -:  679:
        -:  680:template <class _Tp, bool = is_integral<_Tp>::value>
        -:  681:struct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};
        -:  682:
        -:  683:template <class _Tp>
        -:  684:struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point
        -:  685:
        -:  686:template <class _Tp, bool = is_arithmetic<_Tp>::value>
        -:  687:struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};
        -:  688:
        -:  689:template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};
        -:  690:
        -:  691:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_unsigned : public __libcpp_is_unsigned<_Tp> {};
        -:  692:
        -:  693:// rank
        -:  694:
        -:  695:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank
        -:  696:    : public integral_constant<size_t, 0> {};
        -:  697:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[]>
        -:  698:    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
        -:  699:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[_Np]>
        -:  700:    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
        -:  701:
        -:  702:// extent
        -:  703:
        -:  704:template <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TYPE_VIS_ONLY extent
        -:  705:    : public integral_constant<size_t, 0> {};
        -:  706:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], 0>
        -:  707:    : public integral_constant<size_t, 0> {};
        -:  708:template <class _Tp, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], _Ip>
        -:  709:    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
        -:  710:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], 0>
        -:  711:    : public integral_constant<size_t, _Np> {};
        -:  712:template <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], _Ip>
        -:  713:    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
        -:  714:
        -:  715:// remove_extent
        -:  716:
        -:  717:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent
        -:  718:    {typedef _Tp type;};
        -:  719:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[]>
        -:  720:    {typedef _Tp type;};
        -:  721:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[_Np]>
        -:  722:    {typedef _Tp type;};
        -:  723:
        -:  724:#if _LIBCPP_STD_VER > 11
        -:  725:template <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;
        -:  726:#endif
        -:  727:
        -:  728:// remove_all_extents
        -:  729:
        -:  730:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents
        -:  731:    {typedef _Tp type;};
        -:  732:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[]>
        -:  733:    {typedef typename remove_all_extents<_Tp>::type type;};
        -:  734:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[_Np]>
        -:  735:    {typedef typename remove_all_extents<_Tp>::type type;};
        -:  736:
        -:  737:#if _LIBCPP_STD_VER > 11
        -:  738:template <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
        -:  739:#endif
        -:  740:
        -:  741:// decay
        -:  742:
        -:  743:template <class _Tp>
        -:  744:struct _LIBCPP_TYPE_VIS_ONLY decay
        -:  745:{
        -:  746:private:
        -:  747:    typedef typename remove_reference<_Tp>::type _Up;
        -:  748:public:
        -:  749:    typedef typename conditional
        -:  750:                     <
        -:  751:                         is_array<_Up>::value,
        -:  752:                         typename remove_extent<_Up>::type*,
        -:  753:                         typename conditional
        -:  754:                         <
        -:  755:                              is_function<_Up>::value,
        -:  756:                              typename add_pointer<_Up>::type,
        -:  757:                              typename remove_cv<_Up>::type
        -:  758:                         >::type
        -:  759:                     >::type type;
        -:  760:};
        -:  761:
        -:  762:#if _LIBCPP_STD_VER > 11
        -:  763:template <class _Tp> using decay_t = typename decay<_Tp>::type;
        -:  764:#endif
        -:  765:
        -:  766:// is_abstract
        -:  767:
        -:  768:namespace __is_abstract_imp
        -:  769:{
        -:  770:template <class _Tp> char  __test(_Tp (*)[1]);
        -:  771:template <class _Tp> __two __test(...);
        -:  772:}
        -:  773:
        -:  774:template <class _Tp, bool = is_class<_Tp>::value>
        -:  775:struct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};
        -:  776:
        -:  777:template <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};
        -:  778:
        -:  779:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_abstract : public __libcpp_abstract<_Tp> {};
        -:  780:
        -:  781:// is_final
        -:  782:
        -:  783:#if _LIBCPP_STD_VER > 11 && __has_feature(is_final)
        -:  784:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY 
        -:  785:is_final : public integral_constant<bool, __is_final(_Tp)> {};
        -:  786:#endif
        -:  787:
        -:  788:// is_base_of
        -:  789:
        -:  790:#ifdef _LIBCPP_HAS_IS_BASE_OF
        -:  791:
        -:  792:template <class _Bp, class _Dp>
        -:  793:struct _LIBCPP_TYPE_VIS_ONLY is_base_of
        -:  794:    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
        -:  795:
        -:  796:#else  // _LIBCPP_HAS_IS_BASE_OF
        -:  797:
        -:  798:namespace __is_base_of_imp
        -:  799:{
        -:  800:template <class _Tp>
        -:  801:struct _Dst
        -:  802:{
        -:  803:    _Dst(const volatile _Tp &);
        -:  804:};
        -:  805:template <class _Tp>
        -:  806:struct _Src
        -:  807:{
        -:  808:    operator const volatile _Tp &();
        -:  809:    template <class _Up> operator const _Dst<_Up> &();
        -:  810:};
        -:  811:template <size_t> struct __one { typedef char type; };
        -:  812:template <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);
        -:  813:template <class _Bp, class _Dp> __two __test(...);
        -:  814:}
        -:  815:
        -:  816:template <class _Bp, class _Dp>
        -:  817:struct _LIBCPP_TYPE_VIS_ONLY is_base_of
        -:  818:    : public integral_constant<bool, is_class<_Bp>::value &&
        -:  819:                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};
        -:  820:
        -:  821:#endif  // _LIBCPP_HAS_IS_BASE_OF
        -:  822:
        -:  823:// is_convertible
        -:  824:
        -:  825:#if __has_feature(is_convertible_to)
        -:  826:
        -:  827:template <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible
        -:  828:    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
        -:  829:                                     !is_abstract<_T2>::value> {};
        -:  830:
        -:  831:#else  // __has_feature(is_convertible_to)
        -:  832:
        -:  833:namespace __is_convertible_imp
        -:  834:{
        -:  835:template <class _Tp> char  __test(_Tp);
        -:  836:template <class _Tp> __two __test(...);
        -:  837:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  838:template <class _Tp> _Tp&& __source();
        -:  839:#else
        -:  840:template <class _Tp> typename remove_reference<_Tp>::type& __source();
        -:  841:#endif
        -:  842:
        -:  843:template <class _Tp, bool _IsArray =    is_array<_Tp>::value,
        -:  844:                     bool _IsFunction = is_function<_Tp>::value,
        -:  845:                     bool _IsVoid =     is_void<_Tp>::value>
        -:  846:                     struct __is_array_function_or_void                          {enum {value = 0};};
        -:  847:template <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};
        -:  848:template <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};
        -:  849:template <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};
        -:  850:}
        -:  851:
        -:  852:template <class _Tp,
        -:  853:    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>
        -:  854:struct __is_convertible_check
        -:  855:{
        -:  856:    static const size_t __v = 0;
        -:  857:};
        -:  858:
        -:  859:template <class _Tp>
        -:  860:struct __is_convertible_check<_Tp, 0>
        -:  861:{
        -:  862:    static const size_t __v = sizeof(_Tp);
        -:  863:};
        -:  864:
        -:  865:template <class _T1, class _T2,
        -:  866:    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,
        -:  867:    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>
        -:  868:struct __is_convertible
        -:  869:    : public integral_constant<bool,
        -:  870:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  871:        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1
        -:  872:#else
        -:  873:        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1
        -:  874:         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value
        -:  875:              && (!is_const<typename remove_reference<_T2>::type>::value
        -:  876:                  || is_volatile<typename remove_reference<_T2>::type>::value)
        -:  877:                  && (is_same<typename remove_cv<_T1>::type,
        -:  878:                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value
        -:  879:                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))
        -:  880:#endif
        -:  881:    >
        -:  882:{};
        -:  883:
        -:  884:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};
        -:  885:
        -:  886:template <class _T1> struct __is_convertible<_T1, const _T1&, 1, 0> : true_type {};
        -:  887:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  888:template <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};
        -:  889:template <class _T1> struct __is_convertible<_T1, const _T1&&, 1, 0> : true_type {};
        -:  890:template <class _T1> struct __is_convertible<_T1, volatile _T1&&, 1, 0> : true_type {};
        -:  891:template <class _T1> struct __is_convertible<_T1, const volatile _T1&&, 1, 0> : true_type {};
        -:  892:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  893:
        -:  894:template <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>
        -:  895:    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};
        -:  896:
        -:  897:template <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>
        -:  898:    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};
        -:  899:
        -:  900:template <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>
        -:  901:    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};
        -:  902:
        -:  903:template <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>
        -:  904:    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};
        -:  905:
        -:  906:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0>                : public false_type {};
        -:  907:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  908:template <class _T1>            struct __is_convertible<_T1, _T1&&, 2, 0>               : public true_type {};
        -:  909:#endif
        -:  910:template <class _T1>            struct __is_convertible<_T1, _T1&, 2, 0>               : public true_type {};
        -:  911:template <class _T1>            struct __is_convertible<_T1, _T1*, 2, 0>               : public true_type {};
        -:  912:template <class _T1>            struct __is_convertible<_T1, _T1*const, 2, 0>          : public true_type {};
        -:  913:template <class _T1>            struct __is_convertible<_T1, _T1*volatile, 2, 0>       : public true_type {};
        -:  914:template <class _T1>            struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};
        -:  915:
        -:  916:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};
        -:  917:
        -:  918:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};
        -:  919:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};
        -:  920:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};
        -:  921:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};
        -:  922:
        -:  923:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};
        -:  924:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};
        -:  925:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};
        -:  926:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};
        -:  927:
        -:  928:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};
        -:  929:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};
        -:  930:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};
        -:  931:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};
        -:  932:
        -:  933:template <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible
        -:  934:    : public __is_convertible<_T1, _T2>
        -:  935:{
        -:  936:    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;
        -:  937:    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;
        -:  938:};
        -:  939:
        -:  940:#endif  // __has_feature(is_convertible_to)
        -:  941:
        -:  942:// is_empty
        -:  943:
        -:  944:#if __has_feature(is_empty) || (_GNUC_VER >= 407)
        -:  945:
        -:  946:template <class _Tp>
        -:  947:struct _LIBCPP_TYPE_VIS_ONLY is_empty
        -:  948:    : public integral_constant<bool, __is_empty(_Tp)> {};
        -:  949:
        -:  950:#else  // __has_feature(is_empty)
        -:  951:
        -:  952:template <class _Tp>
        -:  953:struct __is_empty1
        -:  954:    : public _Tp
        -:  955:{
        -:  956:    double __lx;
        -:  957:};
        -:  958:
        -:  959:struct __is_empty2
        -:  960:{
        -:  961:    double __lx;
        -:  962:};
        -:  963:
        -:  964:template <class _Tp, bool = is_class<_Tp>::value>
        -:  965:struct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
        -:  966:
        -:  967:template <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};
        -:  968:
        -:  969:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_empty : public __libcpp_empty<_Tp> {};
        -:  970:
        -:  971:#endif  // __has_feature(is_empty)
        -:  972:
        -:  973:// is_polymorphic
        -:  974:
        -:  975:#if __has_feature(is_polymorphic) || defined(_LIBCPP_MSVC)
        -:  976:
        -:  977:template <class _Tp>
        -:  978:struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic
        -:  979:    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
        -:  980:
        -:  981:#else
        -:  982:
        -:  983:template<typename _Tp> char &__is_polymorphic_impl(
        -:  984:    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,
        -:  985:                       int>::type);
        -:  986:template<typename _Tp> __two &__is_polymorphic_impl(...);
        -:  987:
        -:  988:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic
        -:  989:    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};
        -:  990:
        -:  991:#endif // __has_feature(is_polymorphic)
        -:  992:
        -:  993:// has_virtual_destructor
        -:  994:
        -:  995:#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)
        -:  996:
        -:  997:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor
        -:  998:    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
        -:  999:
        -: 1000:#else
        -: 1001:
        -: 1002:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor
        -: 1003:    : public false_type {};
        -: 1004:
        -: 1005:#endif
        -: 1006:
        -: 1007:// alignment_of
        -: 1008:
        -: 1009:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY alignment_of
        -: 1010:    : public integral_constant<size_t, __alignof__(_Tp)> {};
        -: 1011:
        -: 1012:// aligned_storage
        -: 1013:
        -: 1014:template <class _Hp, class _Tp>
        -: 1015:struct __type_list
        -: 1016:{
        -: 1017:    typedef _Hp _Head;
        -: 1018:    typedef _Tp _Tail;
        -: 1019:};
        -: 1020:
        -: 1021:struct __nat
        -: 1022:{
        -: 1023:#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
        -: 1024:    __nat() = delete;
        -: 1025:    __nat(const __nat&) = delete;
        -: 1026:    __nat& operator=(const __nat&) = delete;
        -: 1027:    ~__nat() = delete;
        -: 1028:#endif
        -: 1029:};
        -: 1030:
        -: 1031:template <class _Tp>
        -: 1032:struct __align_type
        -: 1033:{
        -: 1034:    static const size_t value = alignment_of<_Tp>::value;
        -: 1035:    typedef _Tp type;
        -: 1036:};
        -: 1037:
        -: 1038:struct __struct_double {long double __lx;};
        -: 1039:struct __struct_double4 {double __lx[4];};
        -: 1040:
        -: 1041:typedef
        -: 1042:    __type_list<__align_type<unsigned char>,
        -: 1043:    __type_list<__align_type<unsigned short>,
        -: 1044:    __type_list<__align_type<unsigned int>,
        -: 1045:    __type_list<__align_type<unsigned long>,
        -: 1046:    __type_list<__align_type<unsigned long long>,
        -: 1047:    __type_list<__align_type<double>,
        -: 1048:    __type_list<__align_type<long double>,
        -: 1049:    __type_list<__align_type<__struct_double>,
        -: 1050:    __type_list<__align_type<__struct_double4>,
        -: 1051:    __type_list<__align_type<int*>,
        -: 1052:    __nat
        -: 1053:    > > > > > > > > > > __all_types;
        -: 1054:
        -: 1055:template <class _TL, size_t _Align> struct __find_pod;
        -: 1056:
        -: 1057:template <class _Hp, size_t _Align>
        -: 1058:struct __find_pod<__type_list<_Hp, __nat>, _Align>
        -: 1059:{
        -: 1060:    typedef typename conditional<
        -: 1061:                             _Align == _Hp::value,
        -: 1062:                             typename _Hp::type,
        -: 1063:                             void
        -: 1064:                         >::type type;
        -: 1065:};
        -: 1066:
        -: 1067:template <class _Hp, class _Tp, size_t _Align>
        -: 1068:struct __find_pod<__type_list<_Hp, _Tp>, _Align>
        -: 1069:{
        -: 1070:    typedef typename conditional<
        -: 1071:                             _Align == _Hp::value,
        -: 1072:                             typename _Hp::type,
        -: 1073:                             typename __find_pod<_Tp, _Align>::type
        -: 1074:                         >::type type;
        -: 1075:};
        -: 1076:
        -: 1077:template <class _TL, size_t _Len> struct __find_max_align;
        -: 1078:
        -: 1079:template <class _Hp, size_t _Len>
        -: 1080:struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};
        -: 1081:
        -: 1082:template <size_t _Len, size_t _A1, size_t _A2>
        -: 1083:struct __select_align
        -: 1084:{
        -: 1085:private:
        -: 1086:    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
        -: 1087:    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
        -: 1088:public:
        -: 1089:    static const size_t value = _Len < __max ? __min : __max;
        -: 1090:};
        -: 1091:
        -: 1092:template <class _Hp, class _Tp, size_t _Len>
        -: 1093:struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
        -: 1094:    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};
        -: 1095:
        -: 1096:template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
        -: 1097:struct _LIBCPP_TYPE_VIS_ONLY aligned_storage
        -: 1098:{
        -: 1099:    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
        -: 1100:    static_assert(!is_void<_Aligner>::value, "");
        -: 1101:    union type
        -: 1102:    {
        -: 1103:        _Aligner __align;
        -: 1104:        unsigned char __data[_Len];
        -: 1105:    };
        -: 1106:};
        -: 1107:
        -: 1108:#if _LIBCPP_STD_VER > 11
        -: 1109:template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
        -: 1110:    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
        -: 1111:#endif
        -: 1112:
        -: 1113:#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \
        -: 1114:template <size_t _Len>\
        -: 1115:struct _LIBCPP_TYPE_VIS_ONLY aligned_storage<_Len, n>\
        -: 1116:{\
        -: 1117:    struct _ALIGNAS(n) type\
        -: 1118:    {\
        -: 1119:        unsigned char __lx[_Len];\
        -: 1120:    };\
        -: 1121:}
        -: 1122:
        -: 1123:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);
        -: 1124:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);
        -: 1125:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);
        -: 1126:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);
        -: 1127:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);
        -: 1128:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);
        -: 1129:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);
        -: 1130:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);
        -: 1131:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);
        -: 1132:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);
        -: 1133:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);
        -: 1134:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);
        -: 1135:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);
        -: 1136:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);
        -: 1137:// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)
        -: 1138:#if !defined(_LIBCPP_MSVC)
        -: 1139:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);
        -: 1140:#endif // !_LIBCPP_MSVC
        -: 1141:
        -: 1142:#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION
        -: 1143:
        -: 1144:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 1145:
        -: 1146:// aligned_union
        -: 1147:
        -: 1148:template <size_t _I0, size_t ..._In>
        -: 1149:struct __static_max;
        -: 1150:
        -: 1151:template <size_t _I0>
        -: 1152:struct __static_max<_I0>
        -: 1153:{
        -: 1154:    static const size_t value = _I0;
        -: 1155:};
        -: 1156:
        -: 1157:template <size_t _I0, size_t _I1, size_t ..._In>
        -: 1158:struct __static_max<_I0, _I1, _In...>
        -: 1159:{
        -: 1160:    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
        -: 1161:                                             __static_max<_I1, _In...>::value;
        -: 1162:};
        -: 1163:
        -: 1164:template <size_t _Len, class _Type0, class ..._Types>
        -: 1165:struct aligned_union
        -: 1166:{
        -: 1167:    static const size_t alignment_value = __static_max<__alignof__(_Type0),
        -: 1168:                                                       __alignof__(_Types)...>::value;
        -: 1169:    static const size_t __len = __static_max<_Len, sizeof(_Type0),
        -: 1170:                                             sizeof(_Types)...>::value;
        -: 1171:    typedef typename aligned_storage<__len, alignment_value>::type type;
        -: 1172:};
        -: 1173:
        -: 1174:#if _LIBCPP_STD_VER > 11
        -: 1175:template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
        -: 1176:#endif
        -: 1177:
        -: 1178:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 1179:
        -: 1180:template <class _Tp>
        -: 1181:struct __numeric_type
        -: 1182:{
        -: 1183:   static void __test(...);
        -: 1184:   static float __test(float);
        -: 1185:   static double __test(char);
        -: 1186:   static double __test(int);
        -: 1187:   static double __test(unsigned);
        -: 1188:   static double __test(long);
        -: 1189:   static double __test(unsigned long);
        -: 1190:   static double __test(long long);
        -: 1191:   static double __test(unsigned long long);
        -: 1192:   static double __test(double);
        -: 1193:   static long double __test(long double);
        -: 1194:
        -: 1195:   typedef decltype(__test(declval<_Tp>())) type;
        -: 1196:   static const bool value = !is_same<type, void>::value;
        -: 1197:};
        -: 1198:
        -: 1199:template <>
        -: 1200:struct __numeric_type<void>
        -: 1201:{
        -: 1202:   static const bool value = true;
        -: 1203:};
        -: 1204:
        -: 1205:// __promote
        -: 1206:
        -: 1207:template <class _A1, class _A2 = void, class _A3 = void,
        -: 1208:          bool = __numeric_type<_A1>::value &&
        -: 1209:                 __numeric_type<_A2>::value &&
        -: 1210:                 __numeric_type<_A3>::value>
        -: 1211:class __promote
        -: 1212:{
        -: 1213:    static const bool value = false;
        -: 1214:};
        -: 1215:
        -: 1216:template <class _A1, class _A2, class _A3>
        -: 1217:class __promote<_A1, _A2, _A3, true>
        -: 1218:{
        -: 1219:private:
        -: 1220:    typedef typename __promote<_A1>::type __type1;
        -: 1221:    typedef typename __promote<_A2>::type __type2;
        -: 1222:    typedef typename __promote<_A3>::type __type3;
        -: 1223:public:
        -: 1224:    typedef decltype(__type1() + __type2() + __type3()) type;
        -: 1225:    static const bool value = true;
        -: 1226:};
        -: 1227:
        -: 1228:template <class _A1, class _A2>
        -: 1229:class __promote<_A1, _A2, void, true>
        -: 1230:{
        -: 1231:private:
        -: 1232:    typedef typename __promote<_A1>::type __type1;
        -: 1233:    typedef typename __promote<_A2>::type __type2;
        -: 1234:public:
        -: 1235:    typedef decltype(__type1() + __type2()) type;
        -: 1236:    static const bool value = true;
        -: 1237:};
        -: 1238:
        -: 1239:template <class _A1>
        -: 1240:class __promote<_A1, void, void, true>
        -: 1241:{
        -: 1242:public:
        -: 1243:    typedef typename __numeric_type<_A1>::type type;
        -: 1244:    static const bool value = true;
        -: 1245:    static const bool __does_not_throw = _NOEXCEPT_OR_FALSE(static_cast<type>(declval<_A1>()));
        -: 1246:};
        -: 1247:
        -: 1248:#ifdef _LIBCPP_STORE_AS_OPTIMIZATION
        -: 1249:
        -: 1250:// __transform
        -: 1251:
        -: 1252:template <class _Tp, size_t = sizeof(_Tp), bool = is_scalar<_Tp>::value> struct __transform {typedef _Tp type;};
        -: 1253:template <class _Tp> struct __transform<_Tp, 1, true> {typedef unsigned char      type;};
        -: 1254:template <class _Tp> struct __transform<_Tp, 2, true> {typedef unsigned short     type;};
        -: 1255:template <class _Tp> struct __transform<_Tp, 4, true> {typedef unsigned int       type;};
        -: 1256:template <class _Tp> struct __transform<_Tp, 8, true> {typedef unsigned long long type;};
        -: 1257:
        -: 1258:#endif  // _LIBCPP_STORE_AS_OPTIMIZATION
        -: 1259:
        -: 1260:// make_signed / make_unsigned
        -: 1261:
        -: 1262:typedef
        -: 1263:    __type_list<signed char,
        -: 1264:    __type_list<signed short,
        -: 1265:    __type_list<signed int,
        -: 1266:    __type_list<signed long,
        -: 1267:    __type_list<signed long long,
        -: 1268:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1269:    __type_list<__int128_t,
        -: 1270:#endif
        -: 1271:    __nat
        -: 1272:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1273:    >
        -: 1274:#endif
        -: 1275:    > > > > > __signed_types;
        -: 1276:
        -: 1277:typedef
        -: 1278:    __type_list<unsigned char,
        -: 1279:    __type_list<unsigned short,
        -: 1280:    __type_list<unsigned int,
        -: 1281:    __type_list<unsigned long,
        -: 1282:    __type_list<unsigned long long,
        -: 1283:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1284:    __type_list<__uint128_t,
        -: 1285:#endif
        -: 1286:    __nat
        -: 1287:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1288:    >
        -: 1289:#endif
        -: 1290:    > > > > > __unsigned_types;
        -: 1291:
        -: 1292:template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;
        -: 1293:
        -: 1294:template <class _Hp, class _Tp, size_t _Size>
        -: 1295:struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
        -: 1296:{
        -: 1297:    typedef _Hp type;
        -: 1298:};
        -: 1299:
        -: 1300:template <class _Hp, class _Tp, size_t _Size>
        -: 1301:struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
        -: 1302:{
        -: 1303:    typedef typename __find_first<_Tp, _Size>::type type;
        -: 1304:};
        -: 1305:
        -: 1306:template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
        -: 1307:                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
        -: 1308:struct __apply_cv
        -: 1309:{
        -: 1310:    typedef _Up type;
        -: 1311:};
        -: 1312:
        -: 1313:template <class _Tp, class _Up>
        -: 1314:struct __apply_cv<_Tp, _Up, true, false>
        -: 1315:{
        -: 1316:    typedef const _Up type;
        -: 1317:};
        -: 1318:
        -: 1319:template <class _Tp, class _Up>
        -: 1320:struct __apply_cv<_Tp, _Up, false, true>
        -: 1321:{
        -: 1322:    typedef volatile _Up type;
        -: 1323:};
        -: 1324:
        -: 1325:template <class _Tp, class _Up>
        -: 1326:struct __apply_cv<_Tp, _Up, true, true>
        -: 1327:{
        -: 1328:    typedef const volatile _Up type;
        -: 1329:};
        -: 1330:
        -: 1331:template <class _Tp, class _Up>
        -: 1332:struct __apply_cv<_Tp&, _Up, false, false>
        -: 1333:{
        -: 1334:    typedef _Up& type;
        -: 1335:};
        -: 1336:
        -: 1337:template <class _Tp, class _Up>
        -: 1338:struct __apply_cv<_Tp&, _Up, true, false>
        -: 1339:{
        -: 1340:    typedef const _Up& type;
        -: 1341:};
        -: 1342:
        -: 1343:template <class _Tp, class _Up>
        -: 1344:struct __apply_cv<_Tp&, _Up, false, true>
        -: 1345:{
        -: 1346:    typedef volatile _Up& type;
        -: 1347:};
        -: 1348:
        -: 1349:template <class _Tp, class _Up>
        -: 1350:struct __apply_cv<_Tp&, _Up, true, true>
        -: 1351:{
        -: 1352:    typedef const volatile _Up& type;
        -: 1353:};
        -: 1354:
        -: 1355:template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
        -: 1356:struct __make_signed {};
        -: 1357:
        -: 1358:template <class _Tp>
        -: 1359:struct __make_signed<_Tp, true>
        -: 1360:{
        -: 1361:    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
        -: 1362:};
        -: 1363:
        -: 1364:template <> struct __make_signed<bool,               true> {};
        -: 1365:template <> struct __make_signed<  signed short,     true> {typedef short     type;};
        -: 1366:template <> struct __make_signed<unsigned short,     true> {typedef short     type;};
        -: 1367:template <> struct __make_signed<  signed int,       true> {typedef int       type;};
        -: 1368:template <> struct __make_signed<unsigned int,       true> {typedef int       type;};
        -: 1369:template <> struct __make_signed<  signed long,      true> {typedef long      type;};
        -: 1370:template <> struct __make_signed<unsigned long,      true> {typedef long      type;};
        -: 1371:template <> struct __make_signed<  signed long long, true> {typedef long long type;};
        -: 1372:template <> struct __make_signed<unsigned long long, true> {typedef long long type;};
        -: 1373:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1374:template <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};
        -: 1375:template <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};
        -: 1376:#endif
        -: 1377:
        -: 1378:template <class _Tp>
        -: 1379:struct _LIBCPP_TYPE_VIS_ONLY make_signed
        -: 1380:{
        -: 1381:    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
        -: 1382:};
        -: 1383:
        -: 1384:#if _LIBCPP_STD_VER > 11
        -: 1385:template <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;
        -: 1386:#endif
        -: 1387:
        -: 1388:template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
        -: 1389:struct __make_unsigned {};
        -: 1390:
        -: 1391:template <class _Tp>
        -: 1392:struct __make_unsigned<_Tp, true>
        -: 1393:{
        -: 1394:    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
        -: 1395:};
        -: 1396:
        -: 1397:template <> struct __make_unsigned<bool,               true> {};
        -: 1398:template <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};
        -: 1399:template <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};
        -: 1400:template <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};
        -: 1401:template <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};
        -: 1402:template <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};
        -: 1403:template <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};
        -: 1404:template <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};
        -: 1405:template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};
        -: 1406:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1407:template <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};
        -: 1408:template <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};
        -: 1409:#endif
        -: 1410:
        -: 1411:template <class _Tp>
        -: 1412:struct _LIBCPP_TYPE_VIS_ONLY make_unsigned
        -: 1413:{
        -: 1414:    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
        -: 1415:};
        -: 1416:
        -: 1417:#if _LIBCPP_STD_VER > 11
        -: 1418:template <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
        -: 1419:#endif
        -: 1420:
        -: 1421:#ifdef _LIBCPP_HAS_NO_VARIADICS
        -: 1422:
        -: 1423:template <class _Tp, class _Up = void, class V = void>
        -: 1424:struct _LIBCPP_TYPE_VIS_ONLY common_type
        -: 1425:{
        -: 1426:public:
        -: 1427:    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;
        -: 1428:};
        -: 1429:
        -: 1430:template <class _Tp>
        -: 1431:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, void, void>
        -: 1432:{
        -: 1433:public:
        -: 1434:    typedef typename decay<_Tp>::type type;
        -: 1435:};
        -: 1436:
        -: 1437:template <class _Tp, class _Up>
        -: 1438:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, void>
        -: 1439:{
        -: 1440:private:
        -: 1441:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1442:    static _Tp&& __t();
        -: 1443:    static _Up&& __u();
        -: 1444:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1445:    static _Tp __t();
        -: 1446:    static _Up __u();
        -: 1447:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1448:public:
        -: 1449:    typedef typename remove_reference<decltype(true ? __t() : __u())>::type type;
        -: 1450:};
        -: 1451:
        -: 1452:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 1453:
        -: 1454:template <class ..._Tp> struct common_type;
        -: 1455:
        -: 1456:template <class _Tp>
        -: 1457:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp>
        -: 1458:{
        -: 1459:    typedef typename decay<_Tp>::type type;
        -: 1460:};
        -: 1461:
        -: 1462:template <class _Tp, class _Up>
        -: 1463:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up>
        -: 1464:{
        -: 1465:private:
        -: 1466:    static _Tp&& __t();
        -: 1467:    static _Up&& __u();
        -: 1468:    static bool __f();
        -: 1469:public:
        -: 1470:    typedef typename decay<decltype(__f() ? __t() : __u())>::type type;
        -: 1471:};
        -: 1472:
        -: 1473:template <class _Tp, class _Up, class ..._Vp>
        -: 1474:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, _Vp...>
        -: 1475:{
        -: 1476:    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;
        -: 1477:};
        -: 1478:
        -: 1479:#if _LIBCPP_STD_VER > 11
        -: 1480:template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
        -: 1481:#endif
        -: 1482:
        -: 1483:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 1484:
        -: 1485:// is_assignable
        -: 1486:
        -: 1487:template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };
        -: 1488:
        -: 1489:template <class _Tp, class _Arg>
        -: 1490:typename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type
        -: 1491:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1492:__is_assignable_test(_Tp&&, _Arg&&);
        -: 1493:#else
        -: 1494:__is_assignable_test(_Tp, _Arg&);
        -: 1495:#endif
        -: 1496:
        -: 1497:template <class _Arg>
        -: 1498:false_type
        -: 1499:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1500:__is_assignable_test(__any, _Arg&&);
        -: 1501:#else
        -: 1502:__is_assignable_test(__any, _Arg&);
        -: 1503:#endif
        -: 1504:
        -: 1505:template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
        -: 1506:struct __is_assignable_imp
        -: 1507:    : public common_type
        -: 1508:        <
        -: 1509:            decltype(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))
        -: 1510:        >::type {};
        -: 1511:
        -: 1512:template <class _Tp, class _Arg>
        -: 1513:struct __is_assignable_imp<_Tp, _Arg, true>
        -: 1514:    : public false_type
        -: 1515:{
        -: 1516:};
        -: 1517:
        -: 1518:template <class _Tp, class _Arg>
        -: 1519:struct is_assignable
        -: 1520:    : public __is_assignable_imp<_Tp, _Arg> {};
        -: 1521:
        -: 1522:// is_copy_assignable
        -: 1523:
        -: 1524:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_copy_assignable
        -: 1525:    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 1526:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 1527:
        -: 1528:// is_move_assignable
        -: 1529:
        -: 1530:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_move_assignable
        -: 1531:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1532:    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 1533:                     const typename add_rvalue_reference<_Tp>::type> {};
        -: 1534:#else
        -: 1535:    : public is_copy_assignable<_Tp> {};
        -: 1536:#endif
        -: 1537:
        -: 1538:// is_destructible
        -: 1539:
        -: 1540://	if it's a reference, return true
        -: 1541://	if it's a function, return false
        -: 1542://	if it's   void,     return false
        -: 1543://	if it's an array of unknown bound, return false
        -: 1544://	Otherwise, return "std::declval<_Up&>().~_Up()" is well-formed
        -: 1545://    where _Up is remove_all_extents<_Tp>::type
        -: 1546:
        -: 1547:template <class>
        -: 1548:struct __is_destructible_apply { typedef int type; };
        -: 1549:
        -: 1550:template <typename _Tp>
        -: 1551:struct __is_destructor_wellformed {
        -: 1552:	template <typename _Tp1>
        -: 1553:	static char  __test (
        -: 1554:        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type
        -: 1555:    );
        -: 1556:
        -: 1557:	template <typename _Tp1>
        -: 1558:	static __two __test (...);
        -: 1559:	
        -: 1560:	static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
        -: 1561:};
        -: 1562:
        -: 1563:template <class _Tp, bool>
        -: 1564:struct __destructible_imp;
        -: 1565:
        -: 1566:template <class _Tp>
        -: 1567:struct __destructible_imp<_Tp, false> 
        -: 1568:   : public _VSTD::integral_constant<bool, 
        -: 1569:        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};
        -: 1570:
        -: 1571:template <class _Tp>
        -: 1572:struct __destructible_imp<_Tp, true>
        -: 1573:    : public _VSTD::true_type {};
        -: 1574:
        -: 1575:template <class _Tp, bool>
        -: 1576:struct __destructible_false;
        -: 1577:
        -: 1578:template <class _Tp>
        -: 1579:struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};
        -: 1580:
        -: 1581:template <class _Tp>
        -: 1582:struct __destructible_false<_Tp, true> : public _VSTD::false_type {};
        -: 1583:
        -: 1584:template <class _Tp>
        -: 1585:struct is_destructible
        -: 1586:    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};
        -: 1587:
        -: 1588:template <class _Tp>
        -: 1589:struct is_destructible<_Tp[]>
        -: 1590:    : public _VSTD::false_type {};
        -: 1591:
        -: 1592:template <>
        -: 1593:struct is_destructible<void>
        -: 1594:    : public _VSTD::false_type {};
        -: 1595:
        -: 1596:// move
        -: 1597:
        -: 1598:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1599:
        -: 1600:template <class _Tp>
        -: 1601:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -: 1602:typename remove_reference<_Tp>::type&&
        -: 1603:move(_Tp&& __t) _NOEXCEPT
        -: 1604:{
        -: 1605:    typedef typename remove_reference<_Tp>::type _Up;
        -: 1606:    return static_cast<_Up&&>(__t);
        -: 1607:}
        -: 1608:
        -: 1609:template <class _Tp>
        -: 1610:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -: 1611:_Tp&&
function _ZNSt3__17forwardINS_9allocatorIcEEEEOT_RNS_16remove_referenceIS3_E4typeE called 4 returned 100% blocks executed 100%
        -: 1612:forward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT
        -: 1613:{
        4: 1614:    return static_cast<_Tp&&>(__t);
        -: 1615:}
        -: 1616:
        -: 1617:template <class _Tp>
        -: 1618:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -: 1619:_Tp&&
        -: 1620:forward(typename std::remove_reference<_Tp>::type&& __t) _NOEXCEPT
        -: 1621:{
        -: 1622:    static_assert(!std::is_lvalue_reference<_Tp>::value,
        -: 1623:                  "Can not forward an rvalue as an lvalue.");
        -: 1624:    return static_cast<_Tp&&>(__t);
        -: 1625:}
        -: 1626:
        -: 1627:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1628:
        -: 1629:template <class _Tp>
        -: 1630:inline _LIBCPP_INLINE_VISIBILITY
        -: 1631:_Tp&
        -: 1632:move(_Tp& __t)
        -: 1633:{
        -: 1634:    return __t;
        -: 1635:}
        -: 1636:
        -: 1637:template <class _Tp>
        -: 1638:inline _LIBCPP_INLINE_VISIBILITY
        -: 1639:const _Tp&
        -: 1640:move(const _Tp& __t)
        -: 1641:{
        -: 1642:    return __t;
        -: 1643:}
        -: 1644:
        -: 1645:template <class _Tp>
        -: 1646:inline _LIBCPP_INLINE_VISIBILITY
        -: 1647:_Tp&
        -: 1648:forward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT
        -: 1649:{
        -: 1650:    return __t;
        -: 1651:}
        -: 1652:
        -: 1653:
        -: 1654:template <class _Tp>
        -: 1655:class __rv
        -: 1656:{
        -: 1657:    typedef typename remove_reference<_Tp>::type _Trr;
        -: 1658:    _Trr& t_;
        -: 1659:public:
        -: 1660:    _LIBCPP_INLINE_VISIBILITY
        -: 1661:    _Trr* operator->() {return &t_;}
        -: 1662:    _LIBCPP_INLINE_VISIBILITY
        -: 1663:    explicit __rv(_Trr& __t) : t_(__t) {}
        -: 1664:};
        -: 1665:
        -: 1666:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1667:
        -: 1668:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1669:
        -: 1670:template <class _Tp>
        -: 1671:inline _LIBCPP_INLINE_VISIBILITY
        -: 1672:typename decay<_Tp>::type
        -: 1673:__decay_copy(_Tp&& __t)
        -: 1674:{
        -: 1675:    return _VSTD::forward<_Tp>(__t);
        -: 1676:}
        -: 1677:
        -: 1678:#else
        -: 1679:
        -: 1680:template <class _Tp>
        -: 1681:inline _LIBCPP_INLINE_VISIBILITY
        -: 1682:typename decay<_Tp>::type
        -: 1683:__decay_copy(const _Tp& __t)
        -: 1684:{
        -: 1685:    return _VSTD::forward<_Tp>(__t);
        -: 1686:}
        -: 1687:
        -: 1688:#endif
        -: 1689:
        -: 1690:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 1691:
        -: 1692:template <class _Rp, class _Class, class ..._Param>
        -: 1693:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
        -: 1694:{
        -: 1695:    typedef _Class _ClassType;
        -: 1696:    typedef _Rp _ReturnType;
        -: 1697:    typedef _Rp (_FnType) (_Param...);
        -: 1698:};
        -: 1699:
        -: 1700:template <class _Rp, class _Class, class ..._Param>
        -: 1701:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
        -: 1702:{
        -: 1703:    typedef _Class _ClassType;
        -: 1704:    typedef _Rp _ReturnType;
        -: 1705:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1706:};
        -: 1707:
        -: 1708:template <class _Rp, class _Class, class ..._Param>
        -: 1709:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
        -: 1710:{
        -: 1711:    typedef _Class const _ClassType;
        -: 1712:    typedef _Rp _ReturnType;
        -: 1713:    typedef _Rp (_FnType) (_Param...);
        -: 1714:};
        -: 1715:
        -: 1716:template <class _Rp, class _Class, class ..._Param>
        -: 1717:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
        -: 1718:{
        -: 1719:    typedef _Class const _ClassType;
        -: 1720:    typedef _Rp _ReturnType;
        -: 1721:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1722:};
        -: 1723:
        -: 1724:template <class _Rp, class _Class, class ..._Param>
        -: 1725:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
        -: 1726:{
        -: 1727:    typedef _Class volatile _ClassType;
        -: 1728:    typedef _Rp _ReturnType;
        -: 1729:    typedef _Rp (_FnType) (_Param...);
        -: 1730:};
        -: 1731:
        -: 1732:template <class _Rp, class _Class, class ..._Param>
        -: 1733:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
        -: 1734:{
        -: 1735:    typedef _Class volatile _ClassType;
        -: 1736:    typedef _Rp _ReturnType;
        -: 1737:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1738:};
        -: 1739:
        -: 1740:template <class _Rp, class _Class, class ..._Param>
        -: 1741:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
        -: 1742:{
        -: 1743:    typedef _Class const volatile _ClassType;
        -: 1744:    typedef _Rp _ReturnType;
        -: 1745:    typedef _Rp (_FnType) (_Param...);
        -: 1746:};
        -: 1747:
        -: 1748:template <class _Rp, class _Class, class ..._Param>
        -: 1749:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
        -: 1750:{
        -: 1751:    typedef _Class const volatile _ClassType;
        -: 1752:    typedef _Rp _ReturnType;
        -: 1753:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1754:};
        -: 1755:
        -: 1756:#if __has_feature(cxx_reference_qualified_functions)
        -: 1757:
        -: 1758:template <class _Rp, class _Class, class ..._Param>
        -: 1759:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
        -: 1760:{
        -: 1761:    typedef _Class& _ClassType;
        -: 1762:    typedef _Rp _ReturnType;
        -: 1763:    typedef _Rp (_FnType) (_Param...);
        -: 1764:};
        -: 1765:
        -: 1766:template <class _Rp, class _Class, class ..._Param>
        -: 1767:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
        -: 1768:{
        -: 1769:    typedef _Class& _ClassType;
        -: 1770:    typedef _Rp _ReturnType;
        -: 1771:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1772:};
        -: 1773:
        -: 1774:template <class _Rp, class _Class, class ..._Param>
        -: 1775:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
        -: 1776:{
        -: 1777:    typedef _Class const& _ClassType;
        -: 1778:    typedef _Rp _ReturnType;
        -: 1779:    typedef _Rp (_FnType) (_Param...);
        -: 1780:};
        -: 1781:
        -: 1782:template <class _Rp, class _Class, class ..._Param>
        -: 1783:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
        -: 1784:{
        -: 1785:    typedef _Class const& _ClassType;
        -: 1786:    typedef _Rp _ReturnType;
        -: 1787:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1788:};
        -: 1789:
        -: 1790:template <class _Rp, class _Class, class ..._Param>
        -: 1791:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
        -: 1792:{
        -: 1793:    typedef _Class volatile& _ClassType;
        -: 1794:    typedef _Rp _ReturnType;
        -: 1795:    typedef _Rp (_FnType) (_Param...);
        -: 1796:};
        -: 1797:
        -: 1798:template <class _Rp, class _Class, class ..._Param>
        -: 1799:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
        -: 1800:{
        -: 1801:    typedef _Class volatile& _ClassType;
        -: 1802:    typedef _Rp _ReturnType;
        -: 1803:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1804:};
        -: 1805:
        -: 1806:template <class _Rp, class _Class, class ..._Param>
        -: 1807:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
        -: 1808:{
        -: 1809:    typedef _Class const volatile& _ClassType;
        -: 1810:    typedef _Rp _ReturnType;
        -: 1811:    typedef _Rp (_FnType) (_Param...);
        -: 1812:};
        -: 1813:
        -: 1814:template <class _Rp, class _Class, class ..._Param>
        -: 1815:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
        -: 1816:{
        -: 1817:    typedef _Class const volatile& _ClassType;
        -: 1818:    typedef _Rp _ReturnType;
        -: 1819:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1820:};
        -: 1821:
        -: 1822:template <class _Rp, class _Class, class ..._Param>
        -: 1823:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
        -: 1824:{
        -: 1825:    typedef _Class&& _ClassType;
        -: 1826:    typedef _Rp _ReturnType;
        -: 1827:    typedef _Rp (_FnType) (_Param...);
        -: 1828:};
        -: 1829:
        -: 1830:template <class _Rp, class _Class, class ..._Param>
        -: 1831:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
        -: 1832:{
        -: 1833:    typedef _Class&& _ClassType;
        -: 1834:    typedef _Rp _ReturnType;
        -: 1835:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1836:};
        -: 1837:
        -: 1838:template <class _Rp, class _Class, class ..._Param>
        -: 1839:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
        -: 1840:{
        -: 1841:    typedef _Class const&& _ClassType;
        -: 1842:    typedef _Rp _ReturnType;
        -: 1843:    typedef _Rp (_FnType) (_Param...);
        -: 1844:};
        -: 1845:
        -: 1846:template <class _Rp, class _Class, class ..._Param>
        -: 1847:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
        -: 1848:{
        -: 1849:    typedef _Class const&& _ClassType;
        -: 1850:    typedef _Rp _ReturnType;
        -: 1851:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1852:};
        -: 1853:
        -: 1854:template <class _Rp, class _Class, class ..._Param>
        -: 1855:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
        -: 1856:{
        -: 1857:    typedef _Class volatile&& _ClassType;
        -: 1858:    typedef _Rp _ReturnType;
        -: 1859:    typedef _Rp (_FnType) (_Param...);
        -: 1860:};
        -: 1861:
        -: 1862:template <class _Rp, class _Class, class ..._Param>
        -: 1863:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
        -: 1864:{
        -: 1865:    typedef _Class volatile&& _ClassType;
        -: 1866:    typedef _Rp _ReturnType;
        -: 1867:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1868:};
        -: 1869:
        -: 1870:template <class _Rp, class _Class, class ..._Param>
        -: 1871:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
        -: 1872:{
        -: 1873:    typedef _Class const volatile&& _ClassType;
        -: 1874:    typedef _Rp _ReturnType;
        -: 1875:    typedef _Rp (_FnType) (_Param...);
        -: 1876:};
        -: 1877:
        -: 1878:template <class _Rp, class _Class, class ..._Param>
        -: 1879:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
        -: 1880:{
        -: 1881:    typedef _Class const volatile&& _ClassType;
        -: 1882:    typedef _Rp _ReturnType;
        -: 1883:    typedef _Rp (_FnType) (_Param..., ...);
        -: 1884:};
        -: 1885:
        -: 1886:#endif  // __has_feature(cxx_reference_qualified_functions)
        -: 1887:
        -: 1888:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 1889:
        -: 1890:template <class _Rp, class _Class>
        -: 1891:struct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>
        -: 1892:{
        -: 1893:    typedef _Class _ClassType;
        -: 1894:    typedef _Rp _ReturnType;
        -: 1895:    typedef _Rp (_FnType) ();
        -: 1896:};
        -: 1897:
        -: 1898:template <class _Rp, class _Class>
        -: 1899:struct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>
        -: 1900:{
        -: 1901:    typedef _Class _ClassType;
        -: 1902:    typedef _Rp _ReturnType;
        -: 1903:    typedef _Rp (_FnType) (...);
        -: 1904:};
        -: 1905:
        -: 1906:template <class _Rp, class _Class, class _P0>
        -: 1907:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>
        -: 1908:{
        -: 1909:    typedef _Class _ClassType;
        -: 1910:    typedef _Rp _ReturnType;
        -: 1911:    typedef _Rp (_FnType) (_P0);
        -: 1912:};
        -: 1913:
        -: 1914:template <class _Rp, class _Class, class _P0>
        -: 1915:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>
        -: 1916:{
        -: 1917:    typedef _Class _ClassType;
        -: 1918:    typedef _Rp _ReturnType;
        -: 1919:    typedef _Rp (_FnType) (_P0, ...);
        -: 1920:};
        -: 1921:
        -: 1922:template <class _Rp, class _Class, class _P0, class _P1>
        -: 1923:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>
        -: 1924:{
        -: 1925:    typedef _Class _ClassType;
        -: 1926:    typedef _Rp _ReturnType;
        -: 1927:    typedef _Rp (_FnType) (_P0, _P1);
        -: 1928:};
        -: 1929:
        -: 1930:template <class _Rp, class _Class, class _P0, class _P1>
        -: 1931:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>
        -: 1932:{
        -: 1933:    typedef _Class _ClassType;
        -: 1934:    typedef _Rp _ReturnType;
        -: 1935:    typedef _Rp (_FnType) (_P0, _P1, ...);
        -: 1936:};
        -: 1937:
        -: 1938:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 1939:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>
        -: 1940:{
        -: 1941:    typedef _Class _ClassType;
        -: 1942:    typedef _Rp _ReturnType;
        -: 1943:    typedef _Rp (_FnType) (_P0, _P1, _P2);
        -: 1944:};
        -: 1945:
        -: 1946:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 1947:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>
        -: 1948:{
        -: 1949:    typedef _Class _ClassType;
        -: 1950:    typedef _Rp _ReturnType;
        -: 1951:    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
        -: 1952:};
        -: 1953:
        -: 1954:template <class _Rp, class _Class>
        -: 1955:struct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>
        -: 1956:{
        -: 1957:    typedef _Class const _ClassType;
        -: 1958:    typedef _Rp _ReturnType;
        -: 1959:    typedef _Rp (_FnType) ();
        -: 1960:};
        -: 1961:
        -: 1962:template <class _Rp, class _Class>
        -: 1963:struct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>
        -: 1964:{
        -: 1965:    typedef _Class const _ClassType;
        -: 1966:    typedef _Rp _ReturnType;
        -: 1967:    typedef _Rp (_FnType) (...);
        -: 1968:};
        -: 1969:
        -: 1970:template <class _Rp, class _Class, class _P0>
        -: 1971:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>
        -: 1972:{
        -: 1973:    typedef _Class const _ClassType;
        -: 1974:    typedef _Rp _ReturnType;
        -: 1975:    typedef _Rp (_FnType) (_P0);
        -: 1976:};
        -: 1977:
        -: 1978:template <class _Rp, class _Class, class _P0>
        -: 1979:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>
        -: 1980:{
        -: 1981:    typedef _Class const _ClassType;
        -: 1982:    typedef _Rp _ReturnType;
        -: 1983:    typedef _Rp (_FnType) (_P0, ...);
        -: 1984:};
        -: 1985:
        -: 1986:template <class _Rp, class _Class, class _P0, class _P1>
        -: 1987:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>
        -: 1988:{
        -: 1989:    typedef _Class const _ClassType;
        -: 1990:    typedef _Rp _ReturnType;
        -: 1991:    typedef _Rp (_FnType) (_P0, _P1);
        -: 1992:};
        -: 1993:
        -: 1994:template <class _Rp, class _Class, class _P0, class _P1>
        -: 1995:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>
        -: 1996:{
        -: 1997:    typedef _Class const _ClassType;
        -: 1998:    typedef _Rp _ReturnType;
        -: 1999:    typedef _Rp (_FnType) (_P0, _P1, ...);
        -: 2000:};
        -: 2001:
        -: 2002:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2003:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>
        -: 2004:{
        -: 2005:    typedef _Class const _ClassType;
        -: 2006:    typedef _Rp _ReturnType;
        -: 2007:    typedef _Rp (_FnType) (_P0, _P1, _P2);
        -: 2008:};
        -: 2009:
        -: 2010:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2011:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>
        -: 2012:{
        -: 2013:    typedef _Class const _ClassType;
        -: 2014:    typedef _Rp _ReturnType;
        -: 2015:    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
        -: 2016:};
        -: 2017:
        -: 2018:template <class _Rp, class _Class>
        -: 2019:struct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>
        -: 2020:{
        -: 2021:    typedef _Class volatile _ClassType;
        -: 2022:    typedef _Rp _ReturnType;
        -: 2023:    typedef _Rp (_FnType) ();
        -: 2024:};
        -: 2025:
        -: 2026:template <class _Rp, class _Class>
        -: 2027:struct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>
        -: 2028:{
        -: 2029:    typedef _Class volatile _ClassType;
        -: 2030:    typedef _Rp _ReturnType;
        -: 2031:    typedef _Rp (_FnType) (...);
        -: 2032:};
        -: 2033:
        -: 2034:template <class _Rp, class _Class, class _P0>
        -: 2035:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>
        -: 2036:{
        -: 2037:    typedef _Class volatile _ClassType;
        -: 2038:    typedef _Rp _ReturnType;
        -: 2039:    typedef _Rp (_FnType) (_P0);
        -: 2040:};
        -: 2041:
        -: 2042:template <class _Rp, class _Class, class _P0>
        -: 2043:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>
        -: 2044:{
        -: 2045:    typedef _Class volatile _ClassType;
        -: 2046:    typedef _Rp _ReturnType;
        -: 2047:    typedef _Rp (_FnType) (_P0, ...);
        -: 2048:};
        -: 2049:
        -: 2050:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2051:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>
        -: 2052:{
        -: 2053:    typedef _Class volatile _ClassType;
        -: 2054:    typedef _Rp _ReturnType;
        -: 2055:    typedef _Rp (_FnType) (_P0, _P1);
        -: 2056:};
        -: 2057:
        -: 2058:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2059:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>
        -: 2060:{
        -: 2061:    typedef _Class volatile _ClassType;
        -: 2062:    typedef _Rp _ReturnType;
        -: 2063:    typedef _Rp (_FnType) (_P0, _P1, ...);
        -: 2064:};
        -: 2065:
        -: 2066:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2067:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>
        -: 2068:{
        -: 2069:    typedef _Class volatile _ClassType;
        -: 2070:    typedef _Rp _ReturnType;
        -: 2071:    typedef _Rp (_FnType) (_P0, _P1, _P2);
        -: 2072:};
        -: 2073:
        -: 2074:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2075:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>
        -: 2076:{
        -: 2077:    typedef _Class volatile _ClassType;
        -: 2078:    typedef _Rp _ReturnType;
        -: 2079:    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
        -: 2080:};
        -: 2081:
        -: 2082:template <class _Rp, class _Class>
        -: 2083:struct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>
        -: 2084:{
        -: 2085:    typedef _Class const volatile _ClassType;
        -: 2086:    typedef _Rp _ReturnType;
        -: 2087:    typedef _Rp (_FnType) ();
        -: 2088:};
        -: 2089:
        -: 2090:template <class _Rp, class _Class>
        -: 2091:struct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>
        -: 2092:{
        -: 2093:    typedef _Class const volatile _ClassType;
        -: 2094:    typedef _Rp _ReturnType;
        -: 2095:    typedef _Rp (_FnType) (...);
        -: 2096:};
        -: 2097:
        -: 2098:template <class _Rp, class _Class, class _P0>
        -: 2099:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>
        -: 2100:{
        -: 2101:    typedef _Class const volatile _ClassType;
        -: 2102:    typedef _Rp _ReturnType;
        -: 2103:    typedef _Rp (_FnType) (_P0);
        -: 2104:};
        -: 2105:
        -: 2106:template <class _Rp, class _Class, class _P0>
        -: 2107:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>
        -: 2108:{
        -: 2109:    typedef _Class const volatile _ClassType;
        -: 2110:    typedef _Rp _ReturnType;
        -: 2111:    typedef _Rp (_FnType) (_P0, ...);
        -: 2112:};
        -: 2113:
        -: 2114:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2115:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>
        -: 2116:{
        -: 2117:    typedef _Class const volatile _ClassType;
        -: 2118:    typedef _Rp _ReturnType;
        -: 2119:    typedef _Rp (_FnType) (_P0, _P1);
        -: 2120:};
        -: 2121:
        -: 2122:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2123:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>
        -: 2124:{
        -: 2125:    typedef _Class const volatile _ClassType;
        -: 2126:    typedef _Rp _ReturnType;
        -: 2127:    typedef _Rp (_FnType) (_P0, _P1, ...);
        -: 2128:};
        -: 2129:
        -: 2130:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2131:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>
        -: 2132:{
        -: 2133:    typedef _Class const volatile _ClassType;
        -: 2134:    typedef _Rp _ReturnType;
        -: 2135:    typedef _Rp (_FnType) (_P0, _P1, _P2);
        -: 2136:};
        -: 2137:
        -: 2138:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2139:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>
        -: 2140:{
        -: 2141:    typedef _Class const volatile _ClassType;
        -: 2142:    typedef _Rp _ReturnType;
        -: 2143:    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
        -: 2144:};
        -: 2145:
        -: 2146:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2147:
        -: 2148:template <class _Rp, class _Class>
        -: 2149:struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
        -: 2150:{
        -: 2151:    typedef _Class _ClassType;
        -: 2152:    typedef _Rp _ReturnType;
        -: 2153:};
        -: 2154:
        -: 2155:template <class _MP>
        -: 2156:struct __member_pointer_traits
        -: 2157:    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
        -: 2158:                    is_member_function_pointer<_MP>::value,
        -: 2159:                    is_member_object_pointer<_MP>::value>
        -: 2160:{
        -: 2161://     typedef ... _ClassType;
        -: 2162://     typedef ... _ReturnType;
        -: 2163://     typedef ... _FnType;
        -: 2164:};
        -: 2165:
        -: 2166:// result_of
        -: 2167:
        -: 2168:template <class _Callable> class result_of;
        -: 2169:
        -: 2170:#ifdef _LIBCPP_HAS_NO_VARIADICS
        -: 2171:
        -: 2172:template <class _Fn, bool, bool>
        -: 2173:class __result_of
        -: 2174:{
        -: 2175:};
        -: 2176:
        -: 2177:template <class _Fn>
        -: 2178:class __result_of<_Fn(), true, false>
        -: 2179:{
        -: 2180:public:
        -: 2181:    typedef decltype(declval<_Fn>()()) type;
        -: 2182:};
        -: 2183:
        -: 2184:template <class _Fn, class _A0>
        -: 2185:class __result_of<_Fn(_A0), true, false>
        -: 2186:{
        -: 2187:public:
        -: 2188:    typedef decltype(declval<_Fn>()(declval<_A0>())) type;
        -: 2189:};
        -: 2190:
        -: 2191:template <class _Fn, class _A0, class _A1>
        -: 2192:class __result_of<_Fn(_A0, _A1), true, false>
        -: 2193:{
        -: 2194:public:
        -: 2195:    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;
        -: 2196:};
        -: 2197:
        -: 2198:template <class _Fn, class _A0, class _A1, class _A2>
        -: 2199:class __result_of<_Fn(_A0, _A1, _A2), true, false>
        -: 2200:{
        -: 2201:public:
        -: 2202:    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;
        -: 2203:};
        -: 2204:
        -: 2205:template <class _MP, class _Tp, bool _IsMemberFunctionPtr>
        -: 2206:struct __result_of_mp;
        -: 2207:
        -: 2208:// member function pointer
        -: 2209:
        -: 2210:template <class _MP, class _Tp>
        -: 2211:struct __result_of_mp<_MP, _Tp, true>
        -: 2212:    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>
        -: 2213:{
        -: 2214:};
        -: 2215:
        -: 2216:// member data pointer
        -: 2217:
        -: 2218:template <class _MP, class _Tp, bool>
        -: 2219:struct __result_of_mdp;
        -: 2220:
        -: 2221:template <class _Rp, class _Class, class _Tp>
        -: 2222:struct __result_of_mdp<_Rp _Class::*, _Tp, false>
        -: 2223:{
        -: 2224:    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;
        -: 2225:};
        -: 2226:
        -: 2227:template <class _Rp, class _Class, class _Tp>
        -: 2228:struct __result_of_mdp<_Rp _Class::*, _Tp, true>
        -: 2229:{
        -: 2230:    typedef typename __apply_cv<_Tp, _Rp>::type& type;
        -: 2231:};
        -: 2232:
        -: 2233:template <class _Rp, class _Class, class _Tp>
        -: 2234:struct __result_of_mp<_Rp _Class::*, _Tp, false>
        -: 2235:    : public __result_of_mdp<_Rp _Class::*, _Tp,
        -: 2236:            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>
        -: 2237:{
        -: 2238:};
        -: 2239:
        -: 2240:
        -: 2241:
        -: 2242:template <class _Fn, class _Tp>
        -: 2243:class __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer
        -: 2244:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 2245:                            _Tp,
        -: 2246:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 2247:{
        -: 2248:};
        -: 2249:
        -: 2250:template <class _Fn, class _Tp, class _A0>
        -: 2251:class __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer
        -: 2252:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 2253:                            _Tp,
        -: 2254:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 2255:{
        -: 2256:};
        -: 2257:
        -: 2258:template <class _Fn, class _Tp, class _A0, class _A1>
        -: 2259:class __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer
        -: 2260:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 2261:                            _Tp,
        -: 2262:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 2263:{
        -: 2264:};
        -: 2265:
        -: 2266:template <class _Fn, class _Tp, class _A0, class _A1, class _A2>
        -: 2267:class __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer
        -: 2268:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 2269:                            _Tp,
        -: 2270:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 2271:{
        -: 2272:};
        -: 2273:
        -: 2274:// result_of
        -: 2275:
        -: 2276:template <class _Fn>
        -: 2277:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fn()>
        -: 2278:    : public __result_of<_Fn(),
        -: 2279:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 2280:                         is_function<typename remove_reference<_Fn>::type>::value,
        -: 2281:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 2282:                        >
        -: 2283:{
        -: 2284:};
        -: 2285:
        -: 2286:template <class _Fn, class _A0>
        -: 2287:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0)>
        -: 2288:    : public __result_of<_Fn(_A0),
        -: 2289:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 2290:                         is_function<typename remove_reference<_Fn>::type>::value,
        -: 2291:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 2292:                        >
        -: 2293:{
        -: 2294:};
        -: 2295:
        -: 2296:template <class _Fn, class _A0, class _A1>
        -: 2297:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1)>
        -: 2298:    : public __result_of<_Fn(_A0, _A1),
        -: 2299:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 2300:                         is_function<typename remove_reference<_Fn>::type>::value,
        -: 2301:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 2302:                        >
        -: 2303:{
        -: 2304:};
        -: 2305:
        -: 2306:template <class _Fn, class _A0, class _A1, class _A2>
        -: 2307:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1, _A2)>
        -: 2308:    : public __result_of<_Fn(_A0, _A1, _A2),
        -: 2309:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 2310:                         is_function<typename remove_reference<_Fn>::type>::value,
        -: 2311:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 2312:                        >
        -: 2313:{
        -: 2314:};
        -: 2315:
        -: 2316:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2317:
        -: 2318:// template <class T, class... Args> struct is_constructible;
        -: 2319:
        -: 2320:namespace __is_construct
        -: 2321:{
        -: 2322:struct __nat {};
        -: 2323:}
        -: 2324:
        -: 2325:#if __has_feature(is_constructible)
        -: 2326:
        -: 2327:template <class _Tp, class ..._Args>
        -: 2328:struct _LIBCPP_TYPE_VIS_ONLY is_constructible
        -: 2329:    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
        -: 2330:    {};
        -: 2331:
        -: 2332:#else
        -: 2333:
        -: 2334:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 2335:
        -: 2336://      main is_constructible test
        -: 2337:
        -: 2338:template <class _Tp, class ..._Args>
        -: 2339:typename __select_2nd<decltype(_VSTD::move(_Tp(_VSTD::declval<_Args>()...))), true_type>::type
        -: 2340:__is_constructible_test(_Tp&&, _Args&& ...);
        -: 2341:
        -: 2342:template <class ..._Args>
        -: 2343:false_type
        -: 2344:__is_constructible_test(__any, _Args&& ...);
        -: 2345:
        -: 2346:template <bool, class _Tp, class... _Args>
        -: 2347:struct __libcpp_is_constructible // false, _Tp is not a scalar
        -: 2348:    : public common_type
        -: 2349:             <
        -: 2350:                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))
        -: 2351:             >::type
        -: 2352:    {};
        -: 2353:
        -: 2354://      function types are not constructible
        -: 2355:
        -: 2356:template <class _Rp, class... _A1, class... _A2>
        -: 2357:struct __libcpp_is_constructible<false, _Rp(_A1...), _A2...>
        -: 2358:    : public false_type
        -: 2359:    {};
        -: 2360:
        -: 2361://      handle scalars and reference types
        -: 2362:
        -: 2363://      Scalars are default constructible, references are not
        -: 2364:
        -: 2365:template <class _Tp>
        -: 2366:struct __libcpp_is_constructible<true, _Tp>
        -: 2367:    : public is_scalar<_Tp>
        -: 2368:    {};
        -: 2369:
        -: 2370://      Scalars and references are constructible from one arg if that arg is
        -: 2371://          implicitly convertible to the scalar or reference.
        -: 2372:
        -: 2373:template <class _Tp>
        -: 2374:struct __is_constructible_ref
        -: 2375:{
        -: 2376:    true_type static __lxx(_Tp);
        -: 2377:    false_type static __lxx(...);
        -: 2378:};
        -: 2379:
        -: 2380:template <class _Tp, class _A0>
        -: 2381:struct __libcpp_is_constructible<true, _Tp, _A0>
        -: 2382:    : public common_type
        -: 2383:             <
        -: 2384:                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))
        -: 2385:             >::type
        -: 2386:    {};
        -: 2387:
        -: 2388://      Scalars and references are not constructible from multiple args.
        -: 2389:
        -: 2390:template <class _Tp, class _A0, class ..._Args>
        -: 2391:struct __libcpp_is_constructible<true, _Tp, _A0, _Args...>
        -: 2392:    : public false_type
        -: 2393:    {};
        -: 2394:
        -: 2395://      Treat scalars and reference types separately
        -: 2396:
        -: 2397:template <bool, class _Tp, class... _Args>
        -: 2398:struct __is_constructible_void_check
        -: 2399:    : public __libcpp_is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 2400:                                _Tp, _Args...>
        -: 2401:    {};
        -: 2402:
        -: 2403://      If any of T or Args is void, is_constructible should be false
        -: 2404:
        -: 2405:template <class _Tp, class... _Args>
        -: 2406:struct __is_constructible_void_check<true, _Tp, _Args...>
        -: 2407:    : public false_type
        -: 2408:    {};
        -: 2409:
        -: 2410:template <class ..._Args> struct __contains_void;
        -: 2411:
        -: 2412:template <> struct __contains_void<> : false_type {};
        -: 2413:
        -: 2414:template <class _A0, class ..._Args>
        -: 2415:struct __contains_void<_A0, _Args...>
        -: 2416:{
        -: 2417:    static const bool value = is_void<_A0>::value ||
        -: 2418:                              __contains_void<_Args...>::value;
        -: 2419:};
        -: 2420:
        -: 2421://      is_constructible entry point
        -: 2422:
        -: 2423:template <class _Tp, class... _Args>
        -: 2424:struct _LIBCPP_TYPE_VIS_ONLY is_constructible
        -: 2425:    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value
        -: 2426:                                        || is_abstract<_Tp>::value,
        -: 2427:                                           _Tp, _Args...>
        -: 2428:    {};
        -: 2429:
        -: 2430://      Array types are default constructible if their element type
        -: 2431://      is default constructible
        -: 2432:
        -: 2433:template <class _Ap, size_t _Np>
        -: 2434:struct __libcpp_is_constructible<false, _Ap[_Np]>
        -: 2435:    : public is_constructible<typename remove_all_extents<_Ap>::type>
        -: 2436:    {};
        -: 2437:
        -: 2438://      Otherwise array types are not constructible by this syntax
        -: 2439:
        -: 2440:template <class _Ap, size_t _Np, class ..._Args>
        -: 2441:struct __libcpp_is_constructible<false, _Ap[_Np], _Args...>
        -: 2442:    : public false_type
        -: 2443:    {};
        -: 2444:
        -: 2445://      Incomplete array types are not constructible
        -: 2446:
        -: 2447:template <class _Ap, class ..._Args>
        -: 2448:struct __libcpp_is_constructible<false, _Ap[], _Args...>
        -: 2449:    : public false_type
        -: 2450:    {};
        -: 2451:
        -: 2452:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 2453:
        -: 2454:// template <class T> struct is_constructible0;
        -: 2455:
        -: 2456://      main is_constructible0 test
        -: 2457:
        -: 2458:template <class _Tp>
        -: 2459:decltype((_Tp(), true_type()))
        -: 2460:__is_constructible0_test(_Tp&);
        -: 2461:
        -: 2462:false_type
        -: 2463:__is_constructible0_test(__any);
        -: 2464:
        -: 2465:template <class _Tp, class _A0>
        -: 2466:decltype((_Tp(_VSTD::declval<_A0>()), true_type()))
        -: 2467:__is_constructible1_test(_Tp&, _A0&);
        -: 2468:
        -: 2469:template <class _A0>
        -: 2470:false_type
        -: 2471:__is_constructible1_test(__any, _A0&);
        -: 2472:
        -: 2473:template <class _Tp, class _A0, class _A1>
        -: 2474:decltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))
        -: 2475:__is_constructible2_test(_Tp&, _A0&, _A1&);
        -: 2476:
        -: 2477:template <class _A0, class _A1>
        -: 2478:false_type
        -: 2479:__is_constructible2_test(__any, _A0&, _A1&);
        -: 2480:
        -: 2481:template <bool, class _Tp>
        -: 2482:struct __is_constructible0_imp // false, _Tp is not a scalar
        -: 2483:    : public common_type
        -: 2484:             <
        -: 2485:                 decltype(__is_constructible0_test(declval<_Tp&>()))
        -: 2486:             >::type
        -: 2487:    {};
        -: 2488:
        -: 2489:template <bool, class _Tp, class _A0>
        -: 2490:struct __is_constructible1_imp // false, _Tp is not a scalar
        -: 2491:    : public common_type
        -: 2492:             <
        -: 2493:                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))
        -: 2494:             >::type
        -: 2495:    {};
        -: 2496:
        -: 2497:template <bool, class _Tp, class _A0, class _A1>
        -: 2498:struct __is_constructible2_imp // false, _Tp is not a scalar
        -: 2499:    : public common_type
        -: 2500:             <
        -: 2501:                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))
        -: 2502:             >::type
        -: 2503:    {};
        -: 2504:
        -: 2505://      handle scalars and reference types
        -: 2506:
        -: 2507://      Scalars are default constructible, references are not
        -: 2508:
        -: 2509:template <class _Tp>
        -: 2510:struct __is_constructible0_imp<true, _Tp>
        -: 2511:    : public is_scalar<_Tp>
        -: 2512:    {};
        -: 2513:
        -: 2514:template <class _Tp, class _A0>
        -: 2515:struct __is_constructible1_imp<true, _Tp, _A0>
        -: 2516:    : public is_convertible<_A0, _Tp>
        -: 2517:    {};
        -: 2518:
        -: 2519:template <class _Tp, class _A0, class _A1>
        -: 2520:struct __is_constructible2_imp<true, _Tp, _A0, _A1>
        -: 2521:    : public false_type
        -: 2522:    {};
        -: 2523:
        -: 2524://      Treat scalars and reference types separately
        -: 2525:
        -: 2526:template <bool, class _Tp>
        -: 2527:struct __is_constructible0_void_check
        -: 2528:    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 2529:                                _Tp>
        -: 2530:    {};
        -: 2531:
        -: 2532:template <bool, class _Tp, class _A0>
        -: 2533:struct __is_constructible1_void_check
        -: 2534:    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 2535:                                _Tp, _A0>
        -: 2536:    {};
        -: 2537:
        -: 2538:template <bool, class _Tp, class _A0, class _A1>
        -: 2539:struct __is_constructible2_void_check
        -: 2540:    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 2541:                                _Tp, _A0, _A1>
        -: 2542:    {};
        -: 2543:
        -: 2544://      If any of T or Args is void, is_constructible should be false
        -: 2545:
        -: 2546:template <class _Tp>
        -: 2547:struct __is_constructible0_void_check<true, _Tp>
        -: 2548:    : public false_type
        -: 2549:    {};
        -: 2550:
        -: 2551:template <class _Tp, class _A0>
        -: 2552:struct __is_constructible1_void_check<true, _Tp, _A0>
        -: 2553:    : public false_type
        -: 2554:    {};
        -: 2555:
        -: 2556:template <class _Tp, class _A0, class _A1>
        -: 2557:struct __is_constructible2_void_check<true, _Tp, _A0, _A1>
        -: 2558:    : public false_type
        -: 2559:    {};
        -: 2560:
        -: 2561://      is_constructible entry point
        -: 2562:
        -: 2563:template <class _Tp, class _A0 = __is_construct::__nat,
        -: 2564:                     class _A1 = __is_construct::__nat>
        -: 2565:struct _LIBCPP_TYPE_VIS_ONLY is_constructible
        -: 2566:    : public __is_constructible2_void_check<is_void<_Tp>::value
        -: 2567:                                        || is_abstract<_Tp>::value
        -: 2568:                                        || is_function<_Tp>::value
        -: 2569:                                        || is_void<_A0>::value
        -: 2570:                                        || is_void<_A1>::value,
        -: 2571:                                           _Tp, _A0, _A1>
        -: 2572:    {};
        -: 2573:
        -: 2574:template <class _Tp>
        -: 2575:struct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>
        -: 2576:    : public __is_constructible0_void_check<is_void<_Tp>::value
        -: 2577:                                        || is_abstract<_Tp>::value
        -: 2578:                                        || is_function<_Tp>::value,
        -: 2579:                                           _Tp>
        -: 2580:    {};
        -: 2581:
        -: 2582:template <class _Tp, class _A0>
        -: 2583:struct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, _A0, __is_construct::__nat>
        -: 2584:    : public __is_constructible1_void_check<is_void<_Tp>::value
        -: 2585:                                        || is_abstract<_Tp>::value
        -: 2586:                                        || is_function<_Tp>::value
        -: 2587:                                        || is_void<_A0>::value,
        -: 2588:                                           _Tp, _A0>
        -: 2589:    {};
        -: 2590:
        -: 2591://      Array types are default constructible if their element type
        -: 2592://      is default constructible
        -: 2593:
        -: 2594:template <class _Ap, size_t _Np>
        -: 2595:struct __is_constructible0_imp<false, _Ap[_Np]>
        -: 2596:    : public is_constructible<typename remove_all_extents<_Ap>::type>
        -: 2597:    {};
        -: 2598:
        -: 2599:template <class _Ap, size_t _Np, class _A0>
        -: 2600:struct __is_constructible1_imp<false, _Ap[_Np], _A0>
        -: 2601:    : public false_type
        -: 2602:    {};
        -: 2603:
        -: 2604:template <class _Ap, size_t _Np, class _A0, class _A1>
        -: 2605:struct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>
        -: 2606:    : public false_type
        -: 2607:    {};
        -: 2608:
        -: 2609://      Incomplete array types are not constructible
        -: 2610:
        -: 2611:template <class _Ap>
        -: 2612:struct __is_constructible0_imp<false, _Ap[]>
        -: 2613:    : public false_type
        -: 2614:    {};
        -: 2615:
        -: 2616:template <class _Ap, class _A0>
        -: 2617:struct __is_constructible1_imp<false, _Ap[], _A0>
        -: 2618:    : public false_type
        -: 2619:    {};
        -: 2620:
        -: 2621:template <class _Ap, class _A0, class _A1>
        -: 2622:struct __is_constructible2_imp<false, _Ap[], _A0, _A1>
        -: 2623:    : public false_type
        -: 2624:    {};
        -: 2625:
        -: 2626:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2627:#endif  // __has_feature(is_constructible)
        -: 2628:
        -: 2629:// is_default_constructible
        -: 2630:
        -: 2631:template <class _Tp>
        -: 2632:struct _LIBCPP_TYPE_VIS_ONLY is_default_constructible
        -: 2633:    : public is_constructible<_Tp>
        -: 2634:    {};
        -: 2635:
        -: 2636:// is_copy_constructible
        -: 2637:
        -: 2638:template <class _Tp>
        -: 2639:struct _LIBCPP_TYPE_VIS_ONLY is_copy_constructible
        -: 2640:    : public is_constructible<_Tp, 
        -: 2641:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 2642:
        -: 2643:// is_move_constructible
        -: 2644:
        -: 2645:template <class _Tp>
        -: 2646:struct _LIBCPP_TYPE_VIS_ONLY is_move_constructible
        -: 2647:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2648:    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 2649:#else
        -: 2650:    : public is_copy_constructible<_Tp>
        -: 2651:#endif
        -: 2652:    {};
        -: 2653:
        -: 2654:// is_trivially_constructible
        -: 2655:
        -: 2656:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 2657:
        -: 2658:#if __has_feature(is_trivially_constructible)
        -: 2659:
        -: 2660:template <class _Tp, class... _Args>
        -: 2661:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible
        -: 2662:    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
        -: 2663:{
        -: 2664:};
        -: 2665:
        -: 2666:#else  // !__has_feature(is_trivially_constructible)
        -: 2667:
        -: 2668:template <class _Tp, class... _Args>
        -: 2669:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible
        -: 2670:    : false_type
        -: 2671:{
        -: 2672:};
        -: 2673:
        -: 2674:template <class _Tp>
        -: 2675:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp>
        -: 2676:#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)
        -: 2677:    : integral_constant<bool, __has_trivial_constructor(_Tp)>
        -: 2678:#else
        -: 2679:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2680:#endif
        -: 2681:{
        -: 2682:};
        -: 2683:
        -: 2684:template <class _Tp>
        -: 2685:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2686:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&&>
        -: 2687:#else
        -: 2688:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp>
        -: 2689:#endif
        -: 2690:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2691:{
        -: 2692:};
        -: 2693:
        -: 2694:template <class _Tp>
        -: 2695:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&>
        -: 2696:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2697:{
        -: 2698:};
        -: 2699:
        -: 2700:template <class _Tp>
        -: 2701:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&>
        -: 2702:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2703:{
        -: 2704:};
        -: 2705:
        -: 2706:#endif  // !__has_feature(is_trivially_constructible)
        -: 2707:
        -: 2708:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 2709:
        -: 2710:template <class _Tp, class _A0 = __is_construct::__nat,
        -: 2711:                     class _A1 = __is_construct::__nat>
        -: 2712:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible
        -: 2713:    : false_type
        -: 2714:{
        -: 2715:};
        -: 2716:
        -: 2717:#if __has_feature(is_trivially_constructible)
        -: 2718:
        -: 2719:template <class _Tp>
        -: 2720:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,
        -: 2721:                                                       __is_construct::__nat>
        -: 2722:    : integral_constant<bool, __is_trivially_constructible(_Tp)>
        -: 2723:{
        -: 2724:};
        -: 2725:
        -: 2726:template <class _Tp>
        -: 2727:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,
        -: 2728:                                                       __is_construct::__nat>
        -: 2729:    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>
        -: 2730:{
        -: 2731:};
        -: 2732:
        -: 2733:template <class _Tp>
        -: 2734:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,
        -: 2735:                                                       __is_construct::__nat>
        -: 2736:    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>
        -: 2737:{
        -: 2738:};
        -: 2739:
        -: 2740:template <class _Tp>
        -: 2741:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,
        -: 2742:                                                       __is_construct::__nat>
        -: 2743:    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>
        -: 2744:{
        -: 2745:};
        -: 2746:
        -: 2747:#else  // !__has_feature(is_trivially_constructible)
        -: 2748:
        -: 2749:template <class _Tp>
        -: 2750:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,
        -: 2751:                                                       __is_construct::__nat>
        -: 2752:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2753:{
        -: 2754:};
        -: 2755:
        -: 2756:template <class _Tp>
        -: 2757:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,
        -: 2758:                                                       __is_construct::__nat>
        -: 2759:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2760:{
        -: 2761:};
        -: 2762:
        -: 2763:template <class _Tp>
        -: 2764:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,
        -: 2765:                                                       __is_construct::__nat>
        -: 2766:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2767:{
        -: 2768:};
        -: 2769:
        -: 2770:template <class _Tp>
        -: 2771:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,
        -: 2772:                                                       __is_construct::__nat>
        -: 2773:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2774:{
        -: 2775:};
        -: 2776:
        -: 2777:#endif  // !__has_feature(is_trivially_constructible)
        -: 2778:
        -: 2779:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2780:
        -: 2781:// is_trivially_default_constructible
        -: 2782:
        -: 2783:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_default_constructible
        -: 2784:    : public is_trivially_constructible<_Tp>
        -: 2785:    {};
        -: 2786:
        -: 2787:// is_trivially_copy_constructible
        -: 2788:
        -: 2789:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_constructible
        -: 2790:    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
        -: 2791:    {};
        -: 2792:
        -: 2793:// is_trivially_move_constructible
        -: 2794:
        -: 2795:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_constructible
        -: 2796:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2797:    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 2798:#else
        -: 2799:    : public is_trivially_copy_constructible<_Tp>
        -: 2800:#endif
        -: 2801:    {};
        -: 2802:
        -: 2803:// is_trivially_assignable
        -: 2804:
        -: 2805:#if __has_feature(is_trivially_assignable)
        -: 2806:
        -: 2807:template <class _Tp, class _Arg>
        -: 2808:struct is_trivially_assignable
        -: 2809:    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
        -: 2810:{
        -: 2811:};
        -: 2812:
        -: 2813:#else  // !__has_feature(is_trivially_assignable)
        -: 2814:
        -: 2815:template <class _Tp, class _Arg>
        -: 2816:struct is_trivially_assignable
        -: 2817:    : public false_type {};
        -: 2818:
        -: 2819:template <class _Tp>
        -: 2820:struct is_trivially_assignable<_Tp&, _Tp>
        -: 2821:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2822:
        -: 2823:template <class _Tp>
        -: 2824:struct is_trivially_assignable<_Tp&, _Tp&>
        -: 2825:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2826:
        -: 2827:template <class _Tp>
        -: 2828:struct is_trivially_assignable<_Tp&, const _Tp&>
        -: 2829:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2830:
        -: 2831:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2832:
        -: 2833:template <class _Tp>
        -: 2834:struct is_trivially_assignable<_Tp&, _Tp&&>
        -: 2835:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2836:
        -: 2837:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2838:
        -: 2839:#endif  // !__has_feature(is_trivially_assignable)
        -: 2840:
        -: 2841:// is_trivially_copy_assignable
        -: 2842:
        -: 2843:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_assignable
        -: 2844:    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 2845:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 2846:
        -: 2847:// is_trivially_move_assignable
        -: 2848:
        -: 2849:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_assignable
        -: 2850:    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 2851:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2852:                                     typename add_rvalue_reference<_Tp>::type>
        -: 2853:#else
        -: 2854:                                     typename add_lvalue_reference<_Tp>::type>
        -: 2855:#endif
        -: 2856:    {};
        -: 2857:
        -: 2858:// is_trivially_destructible
        -: 2859:
        -: 2860:#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)
        -: 2861:
        -: 2862:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible
        -: 2863:    : public integral_constant<bool, __has_trivial_destructor(_Tp)> {};
        -: 2864:
        -: 2865:#else
        -: 2866:
        -: 2867:template <class _Tp> struct __libcpp_trivial_destructor
        -: 2868:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -: 2869:                                     is_reference<_Tp>::value> {};
        -: 2870:
        -: 2871:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible
        -: 2872:    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};
        -: 2873:
        -: 2874:#endif
        -: 2875:
        -: 2876:// is_nothrow_constructible
        -: 2877:
        -: 2878:#if 0
        -: 2879:template <class _Tp, class... _Args>
        -: 2880:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible
        -: 2881:    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>
        -: 2882:{
        -: 2883:};
        -: 2884:
        -: 2885:#else
        -: 2886:
        -: 2887:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 2888:
        -: 2889:#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
        -: 2890:
        -: 2891:template <bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;
        -: 2892:
        -: 2893:template <class _Tp, class... _Args>
        -: 2894:struct __libcpp_is_nothrow_constructible<true, _Tp, _Args...>
        -: 2895:    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
        -: 2896:{
        -: 2897:};
        -: 2898:
        -: 2899:template <class _Tp, class... _Args>
        -: 2900:struct __libcpp_is_nothrow_constructible<false, _Tp, _Args...>
        -: 2901:    : public false_type
        -: 2902:{
        -: 2903:};
        -: 2904:
        -: 2905:template <class _Tp, class... _Args>
        -: 2906:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible
        -: 2907:    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, _Tp, _Args...>
        -: 2908:{
        -: 2909:};
        -: 2910:
        -: 2911:template <class _Tp, size_t _Ns>
        -: 2912:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp[_Ns]>
        -: 2913:    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, _Tp>
        -: 2914:{
        -: 2915:};
        -: 2916:
        -: 2917:#else  // __has_feature(cxx_noexcept)
        -: 2918:
        -: 2919:template <class _Tp, class... _Args>
        -: 2920:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible
        -: 2921:    : false_type
        -: 2922:{
        -: 2923:};
        -: 2924:
        -: 2925:template <class _Tp>
        -: 2926:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp>
        -: 2927:#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
        -: 2928:    : integral_constant<bool, __has_nothrow_constructor(_Tp)>
        -: 2929:#else
        -: 2930:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2931:#endif
        -: 2932:{
        -: 2933:};
        -: 2934:
        -: 2935:template <class _Tp>
        -: 2936:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2937:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&&>
        -: 2938:#else
        -: 2939:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp>
        -: 2940:#endif
        -: 2941:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 2942:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 2943:#else
        -: 2944:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2945:#endif
        -: 2946:{
        -: 2947:};
        -: 2948:
        -: 2949:template <class _Tp>
        -: 2950:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&>
        -: 2951:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 2952:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 2953:#else
        -: 2954:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2955:#endif
        -: 2956:{
        -: 2957:};
        -: 2958:
        -: 2959:template <class _Tp>
        -: 2960:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&>
        -: 2961:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 2962:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 2963:#else
        -: 2964:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2965:#endif
        -: 2966:{
        -: 2967:};
        -: 2968:
        -: 2969:#endif  // __has_feature(cxx_noexcept)
        -: 2970:
        -: 2971:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 2972:
        -: 2973:template <class _Tp, class _A0 = __is_construct::__nat,
        -: 2974:                     class _A1 = __is_construct::__nat>
        -: 2975:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible
        -: 2976:    : false_type
        -: 2977:{
        -: 2978:};
        -: 2979:
        -: 2980:template <class _Tp>
        -: 2981:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, __is_construct::__nat,
        -: 2982:                                                       __is_construct::__nat>
        -: 2983:#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
        -: 2984:    : integral_constant<bool, __has_nothrow_constructor(_Tp)>
        -: 2985:#else
        -: 2986:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2987:#endif
        -: 2988:{
        -: 2989:};
        -: 2990:
        -: 2991:template <class _Tp>
        -: 2992:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp,
        -: 2993:                                                       __is_construct::__nat>
        -: 2994:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 2995:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 2996:#else
        -: 2997:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2998:#endif
        -: 2999:{
        -: 3000:};
        -: 3001:
        -: 3002:template <class _Tp>
        -: 3003:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&,
        -: 3004:                                                       __is_construct::__nat>
        -: 3005:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3006:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3007:#else
        -: 3008:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3009:#endif
        -: 3010:{
        -: 3011:};
        -: 3012:
        -: 3013:template <class _Tp>
        -: 3014:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&,
        -: 3015:                                                       __is_construct::__nat>
        -: 3016:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3017:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3018:#else
        -: 3019:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3020:#endif
        -: 3021:{
        -: 3022:};
        -: 3023:
        -: 3024:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 3025:#endif  // __has_feature(is_nothrow_constructible)
        -: 3026:
        -: 3027:// is_nothrow_default_constructible
        -: 3028:
        -: 3029:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_default_constructible
        -: 3030:    : public is_nothrow_constructible<_Tp>
        -: 3031:    {};
        -: 3032:
        -: 3033:// is_nothrow_copy_constructible
        -: 3034:
        -: 3035:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_constructible
        -: 3036:    : public is_nothrow_constructible<_Tp,
        -: 3037:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 3038:
        -: 3039:// is_nothrow_move_constructible
        -: 3040:
        -: 3041:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_constructible
        -: 3042:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3043:    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 3044:#else
        -: 3045:    : public is_nothrow_copy_constructible<_Tp>
        -: 3046:#endif
        -: 3047:    {};
        -: 3048:
        -: 3049:// is_nothrow_assignable
        -: 3050:
        -: 3051:#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
        -: 3052:
        -: 3053:template <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;
        -: 3054:
        -: 3055:template <class _Tp, class _Arg>
        -: 3056:struct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>
        -: 3057:    : public false_type
        -: 3058:{
        -: 3059:};
        -: 3060:
        -: 3061:template <class _Tp, class _Arg>
        -: 3062:struct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>
        -: 3063:    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >
        -: 3064:{
        -: 3065:};
        -: 3066:
        -: 3067:template <class _Tp, class _Arg>
        -: 3068:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable
        -: 3069:    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>
        -: 3070:{
        -: 3071:};
        -: 3072:
        -: 3073:#else  // __has_feature(cxx_noexcept)
        -: 3074:
        -: 3075:template <class _Tp, class _Arg>
        -: 3076:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable
        -: 3077:    : public false_type {};
        -: 3078:
        -: 3079:template <class _Tp>
        -: 3080:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp>
        -: 3081:#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
        -: 3082:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 3083:#else
        -: 3084:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3085:#endif
        -: 3086:
        -: 3087:template <class _Tp>
        -: 3088:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp&>
        -: 3089:#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
        -: 3090:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 3091:#else
        -: 3092:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3093:#endif
        -: 3094:
        -: 3095:template <class _Tp>
        -: 3096:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, const _Tp&>
        -: 3097:#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
        -: 3098:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 3099:#else
        -: 3100:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3101:#endif
        -: 3102:
        -: 3103:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3104:
        -: 3105:template <class _Tp>
        -: 3106:struct is_nothrow_assignable<_Tp&, _Tp&&>
        -: 3107:#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
        -: 3108:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 3109:#else
        -: 3110:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3111:#endif
        -: 3112:
        -: 3113:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3114:
        -: 3115:#endif  // __has_feature(cxx_noexcept)
        -: 3116:
        -: 3117:// is_nothrow_copy_assignable
        -: 3118:
        -: 3119:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_assignable
        -: 3120:    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 3121:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 3122:
        -: 3123:// is_nothrow_move_assignable
        -: 3124:
        -: 3125:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_assignable
        -: 3126:    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 3127:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3128:                                     typename add_rvalue_reference<_Tp>::type>
        -: 3129:#else
        -: 3130:                                     typename add_lvalue_reference<_Tp>::type>
        -: 3131:#endif
        -: 3132:    {};
        -: 3133:
        -: 3134:// is_nothrow_destructible
        -: 3135:
        -: 3136:#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
        -: 3137:
        -: 3138:template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;
        -: 3139:
        -: 3140:template <class _Tp>
        -: 3141:struct __libcpp_is_nothrow_destructible<false, _Tp>
        -: 3142:    : public false_type
        -: 3143:{
        -: 3144:};
        -: 3145:
        -: 3146:template <class _Tp>
        -: 3147:struct __libcpp_is_nothrow_destructible<true, _Tp>
        -: 3148:    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >
        -: 3149:{
        -: 3150:};
        -: 3151:
        -: 3152:template <class _Tp>
        -: 3153:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible
        -: 3154:    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
        -: 3155:{
        -: 3156:};
        -: 3157:
        -: 3158:template <class _Tp, size_t _Ns>
        -: 3159:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[_Ns]>
        -: 3160:    : public is_nothrow_destructible<_Tp>
        -: 3161:{
        -: 3162:};
        -: 3163:
        -: 3164:template <class _Tp>
        -: 3165:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&>
        -: 3166:    : public true_type
        -: 3167:{
        -: 3168:};
        -: 3169:
        -: 3170:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3171:
        -: 3172:template <class _Tp>
        -: 3173:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&&>
        -: 3174:    : public true_type
        -: 3175:{
        -: 3176:};
        -: 3177:
        -: 3178:#endif
        -: 3179:
        -: 3180:#else
        -: 3181:
        -: 3182:template <class _Tp> struct __libcpp_nothrow_destructor
        -: 3183:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -: 3184:                                     is_reference<_Tp>::value> {};
        -: 3185:
        -: 3186:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible
        -: 3187:    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};
        -: 3188:
        -: 3189:#endif
        -: 3190:
        -: 3191:// is_pod
        -: 3192:
        -: 3193:#if __has_feature(is_pod) || (_GNUC_VER >= 403)
        -: 3194:
        -: 3195:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod
        -: 3196:    : public integral_constant<bool, __is_pod(_Tp)> {};
        -: 3197:
        -: 3198:#else
        -: 3199:
        -: 3200:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod
        -: 3201:    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&
        -: 3202:                                     is_trivially_copy_constructible<_Tp>::value      &&
        -: 3203:                                     is_trivially_copy_assignable<_Tp>::value    &&
        -: 3204:                                     is_trivially_destructible<_Tp>::value> {};
        -: 3205:
        -: 3206:#endif
        -: 3207:
        -: 3208:// is_literal_type;
        -: 3209:
        -: 3210:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_literal_type
        -: 3211:#ifdef _LIBCPP_IS_LITERAL
        -: 3212:    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>
        -: 3213:#else
        -: 3214:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||
        -: 3215:                              is_reference<typename remove_all_extents<_Tp>::type>::value>
        -: 3216:#endif
        -: 3217:    {};
        -: 3218:    
        -: 3219:// is_standard_layout;
        -: 3220:
        -: 3221:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_standard_layout
        -: 3222:#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)
        -: 3223:    : public integral_constant<bool, __is_standard_layout(_Tp)>
        -: 3224:#else
        -: 3225:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
        -: 3226:#endif
        -: 3227:    {};
        -: 3228:    
        -: 3229:// is_trivially_copyable;
        -: 3230:
        -: 3231:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copyable
        -: 3232:#if __has_feature(is_trivially_copyable)
        -: 3233:    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
        -: 3234:#else
        -: 3235:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
        -: 3236:#endif
        -: 3237:    {};
        -: 3238:    
        -: 3239:// is_trivial;
        -: 3240:
        -: 3241:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivial
        -: 3242:#if __has_feature(is_trivial) || (_GNUC_VER >= 407)
        -: 3243:    : public integral_constant<bool, __is_trivial(_Tp)>
        -: 3244:#else
        -: 3245:    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&
        -: 3246:                                 is_trivially_default_constructible<_Tp>::value>
        -: 3247:#endif
        -: 3248:    {};
        -: 3249:
        -: 3250:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 3251:
        -: 3252:// Check for complete types
        -: 3253:
        -: 3254:template <class ..._Tp> struct __check_complete;
        -: 3255:
        -: 3256:template <>
        -: 3257:struct __check_complete<>
        -: 3258:{
        -: 3259:};
        -: 3260:
        -: 3261:template <class _Hp, class _T0, class ..._Tp>
        -: 3262:struct __check_complete<_Hp, _T0, _Tp...>
        -: 3263:    : private __check_complete<_Hp>,
        -: 3264:      private __check_complete<_T0, _Tp...>
        -: 3265:{
        -: 3266:};
        -: 3267:
        -: 3268:template <class _Hp>
        -: 3269:struct __check_complete<_Hp, _Hp>
        -: 3270:    : private __check_complete<_Hp>
        -: 3271:{
        -: 3272:};
        -: 3273:
        -: 3274:template <class _Tp>
        -: 3275:struct __check_complete<_Tp>
        -: 3276:{
        -: 3277:    static_assert(sizeof(_Tp) > 0, "Type must be complete.");
        -: 3278:};
        -: 3279:
        -: 3280:template <class _Tp>
        -: 3281:struct __check_complete<_Tp&>
        -: 3282:    : private __check_complete<_Tp>
        -: 3283:{
        -: 3284:};
        -: 3285:
        -: 3286:template <class _Tp>
        -: 3287:struct __check_complete<_Tp&&>
        -: 3288:    : private __check_complete<_Tp>
        -: 3289:{
        -: 3290:};
        -: 3291:
        -: 3292:template <class _Rp, class ..._Param>
        -: 3293:struct __check_complete<_Rp (*)(_Param...)>
        -: 3294:    : private __check_complete<_Rp>
        -: 3295:{
        -: 3296:};
        -: 3297:
        -: 3298:template <class ..._Param>
        -: 3299:struct __check_complete<void (*)(_Param...)>
        -: 3300:{
        -: 3301:};
        -: 3302:
        -: 3303:template <class _Rp, class ..._Param>
        -: 3304:struct __check_complete<_Rp (_Param...)>
        -: 3305:    : private __check_complete<_Rp>
        -: 3306:{
        -: 3307:};
        -: 3308:
        -: 3309:template <class ..._Param>
        -: 3310:struct __check_complete<void (_Param...)>
        -: 3311:{
        -: 3312:};
        -: 3313:
        -: 3314:template <class _Rp, class _Class, class ..._Param>
        -: 3315:struct __check_complete<_Rp (_Class::*)(_Param...)>
        -: 3316:    : private __check_complete<_Class>
        -: 3317:{
        -: 3318:};
        -: 3319:
        -: 3320:template <class _Rp, class _Class, class ..._Param>
        -: 3321:struct __check_complete<_Rp (_Class::*)(_Param...) const>
        -: 3322:    : private __check_complete<_Class>
        -: 3323:{
        -: 3324:};
        -: 3325:
        -: 3326:template <class _Rp, class _Class, class ..._Param>
        -: 3327:struct __check_complete<_Rp (_Class::*)(_Param...) volatile>
        -: 3328:    : private __check_complete<_Class>
        -: 3329:{
        -: 3330:};
        -: 3331:
        -: 3332:template <class _Rp, class _Class, class ..._Param>
        -: 3333:struct __check_complete<_Rp (_Class::*)(_Param...) const volatile>
        -: 3334:    : private __check_complete<_Class>
        -: 3335:{
        -: 3336:};
        -: 3337:
        -: 3338:#if __has_feature(cxx_reference_qualified_functions)
        -: 3339:
        -: 3340:template <class _Rp, class _Class, class ..._Param>
        -: 3341:struct __check_complete<_Rp (_Class::*)(_Param...) &>
        -: 3342:    : private __check_complete<_Class>
        -: 3343:{
        -: 3344:};
        -: 3345:
        -: 3346:template <class _Rp, class _Class, class ..._Param>
        -: 3347:struct __check_complete<_Rp (_Class::*)(_Param...) const&>
        -: 3348:    : private __check_complete<_Class>
        -: 3349:{
        -: 3350:};
        -: 3351:
        -: 3352:template <class _Rp, class _Class, class ..._Param>
        -: 3353:struct __check_complete<_Rp (_Class::*)(_Param...) volatile&>
        -: 3354:    : private __check_complete<_Class>
        -: 3355:{
        -: 3356:};
        -: 3357:
        -: 3358:template <class _Rp, class _Class, class ..._Param>
        -: 3359:struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>
        -: 3360:    : private __check_complete<_Class>
        -: 3361:{
        -: 3362:};
        -: 3363:
        -: 3364:template <class _Rp, class _Class, class ..._Param>
        -: 3365:struct __check_complete<_Rp (_Class::*)(_Param...) &&>
        -: 3366:    : private __check_complete<_Class>
        -: 3367:{
        -: 3368:};
        -: 3369:
        -: 3370:template <class _Rp, class _Class, class ..._Param>
        -: 3371:struct __check_complete<_Rp (_Class::*)(_Param...) const&&>
        -: 3372:    : private __check_complete<_Class>
        -: 3373:{
        -: 3374:};
        -: 3375:
        -: 3376:template <class _Rp, class _Class, class ..._Param>
        -: 3377:struct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>
        -: 3378:    : private __check_complete<_Class>
        -: 3379:{
        -: 3380:};
        -: 3381:
        -: 3382:template <class _Rp, class _Class, class ..._Param>
        -: 3383:struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>
        -: 3384:    : private __check_complete<_Class>
        -: 3385:{
        -: 3386:};
        -: 3387:
        -: 3388:#endif
        -: 3389:
        -: 3390:template <class _Rp, class _Class>
        -: 3391:struct __check_complete<_Rp _Class::*>
        -: 3392:    : private __check_complete<_Class>
        -: 3393:{
        -: 3394:};
        -: 3395:
        -: 3396:// __invoke forward declarations
        -: 3397:
        -: 3398:// fall back - none of the bullets
        -: 3399:
        -: 3400:template <class ..._Args>
        -: 3401:auto
        -: 3402:__invoke(__any, _Args&& ...__args)
        -: 3403:    -> __nat;
        -: 3404:
        -: 3405:// bullets 1 and 2
        -: 3406:
        -: 3407:template <class _Fp, class _A0, class ..._Args,
        -: 3408:            class = typename enable_if
        -: 3409:            <
        -: 3410:                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&
        -: 3411:                is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,
        -: 3412:                           typename remove_reference<_A0>::type>::value
        -: 3413:            >::type
        -: 3414:         >
        -: 3415:_LIBCPP_INLINE_VISIBILITY
        -: 3416:auto
        -: 3417:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 3418:    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...));
        -: 3419:
        -: 3420:template <class _Fp, class _A0, class ..._Args,
        -: 3421:            class = typename enable_if
        -: 3422:            <
        -: 3423:                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&
        -: 3424:                !is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,
        -: 3425:                           typename remove_reference<_A0>::type>::value
        -: 3426:            >::type
        -: 3427:         >
        -: 3428:_LIBCPP_INLINE_VISIBILITY
        -: 3429:auto
        -: 3430:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 3431:    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...));
        -: 3432:
        -: 3433:// bullets 3 and 4
        -: 3434:
        -: 3435:template <class _Fp, class _A0,
        -: 3436:            class = typename enable_if
        -: 3437:            <
        -: 3438:                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&
        -: 3439:                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,
        -: 3440:                           typename remove_reference<_A0>::type>::value
        -: 3441:            >::type
        -: 3442:         >
        -: 3443:_LIBCPP_INLINE_VISIBILITY
        -: 3444:auto
        -: 3445:__invoke(_Fp&& __f, _A0&& __a0)
        -: 3446:    -> decltype(_VSTD::forward<_A0>(__a0).*__f);
        -: 3447:
        -: 3448:template <class _Fp, class _A0,
        -: 3449:            class = typename enable_if
        -: 3450:            <
        -: 3451:                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&
        -: 3452:                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,
        -: 3453:                           typename remove_reference<_A0>::type>::value
        -: 3454:            >::type
        -: 3455:         >
        -: 3456:_LIBCPP_INLINE_VISIBILITY
        -: 3457:auto
        -: 3458:__invoke(_Fp&& __f, _A0&& __a0)
        -: 3459:    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f);
        -: 3460:
        -: 3461:// bullet 5
        -: 3462:
        -: 3463:template <class _Fp, class ..._Args>
        -: 3464:_LIBCPP_INLINE_VISIBILITY
        -: 3465:auto
        -: 3466:__invoke(_Fp&& __f, _Args&& ...__args)
        -: 3467:    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...));
        -: 3468:
        -: 3469:// __invokable
        -: 3470:
        -: 3471:template <class _Fp, class ..._Args>
        -: 3472:struct __invokable_imp
        -: 3473:    : private __check_complete<_Fp>
        -: 3474:{
        -: 3475:    typedef decltype(
        -: 3476:            __invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)
        -: 3477:                    ) type;
        -: 3478:    static const bool value = !is_same<type, __nat>::value;
        -: 3479:};
        -: 3480:
        -: 3481:template <class _Fp, class ..._Args>
        -: 3482:struct __invokable
        -: 3483:    : public integral_constant<bool,
        -: 3484:          __invokable_imp<_Fp, _Args...>::value>
        -: 3485:{
        -: 3486:};
        -: 3487:
        -: 3488:// __invoke_of
        -: 3489:
        -: 3490:template <bool _Invokable, class _Fp, class ..._Args>
        -: 3491:struct __invoke_of_imp  // false
        -: 3492:{
        -: 3493:};
        -: 3494:
        -: 3495:template <class _Fp, class ..._Args>
        -: 3496:struct __invoke_of_imp<true, _Fp, _Args...>
        -: 3497:{
        -: 3498:    typedef typename __invokable_imp<_Fp, _Args...>::type type;
        -: 3499:};
        -: 3500:
        -: 3501:template <class _Fp, class ..._Args>
        -: 3502:struct __invoke_of
        -: 3503:    : public __invoke_of_imp<__invokable<_Fp, _Args...>::value, _Fp, _Args...>
        -: 3504:{
        -: 3505:};
        -: 3506:
        -: 3507:template <class _Fp, class ..._Args>
        -: 3508:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fp(_Args...)>
        -: 3509:    : public __invoke_of<_Fp, _Args...>
        -: 3510:{
        -: 3511:};
        -: 3512:
        -: 3513:#if _LIBCPP_STD_VER > 11
        -: 3514:template <class _Tp> using result_of_t = typename result_of<_Tp>::type;
        -: 3515:#endif
        -: 3516:
        -: 3517:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 3518:
        -: 3519:template <class _Tp>
        -: 3520:inline _LIBCPP_INLINE_VISIBILITY
        -: 3521:#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE
        -: 3522:typename enable_if
        -: 3523:<
        -: 3524:    is_move_constructible<_Tp>::value &&
        -: 3525:    is_move_assignable<_Tp>::value
        -: 3526:>::type
        -: 3527:#else
        -: 3528:void
        -: 3529:#endif
        -: 3530:swap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&
        -: 3531:                                    is_nothrow_move_assignable<_Tp>::value)
        -: 3532:{
        -: 3533:    _Tp __t(_VSTD::move(__x));
        -: 3534:    __x = _VSTD::move(__y);
        -: 3535:    __y = _VSTD::move(__t);
        -: 3536:}
        -: 3537:
        -: 3538:template <class _ForwardIterator1, class _ForwardIterator2>
        -: 3539:inline _LIBCPP_INLINE_VISIBILITY
        -: 3540:void
        -: 3541:iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        -: 3542:    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))
        -: 3543:               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),
        -: 3544:                                          *_VSTD::declval<_ForwardIterator2>())))
        -: 3545:{
        -: 3546:    swap(*__a, *__b);
        -: 3547:}
        -: 3548:
        -: 3549:// __swappable
        -: 3550:
        -: 3551:namespace __detail
        -: 3552:{
        -: 3553:
        -: 3554:using _VSTD::swap;
        -: 3555:__nat swap(__any, __any);
        -: 3556:
        -: 3557:template <class _Tp>
        -: 3558:struct __swappable
        -: 3559:{
        -: 3560:    typedef decltype(swap(_VSTD::declval<_Tp&>(), _VSTD::declval<_Tp&>())) type;
        -: 3561:    static const bool value = !is_same<type, __nat>::value;
        -: 3562:};
        -: 3563:
        -: 3564:}  // __detail
        -: 3565:
        -: 3566:template <class _Tp>
        -: 3567:struct __is_swappable
        -: 3568:    : public integral_constant<bool, __detail::__swappable<_Tp>::value>
        -: 3569:{
        -: 3570:};
        -: 3571:
        -: 3572:#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
        -: 3573:
        -: 3574:template <bool, class _Tp>
        -: 3575:struct __is_nothrow_swappable_imp
        -: 3576:    : public integral_constant<bool, noexcept(swap(_VSTD::declval<_Tp&>(),
        -: 3577:                                                   _VSTD::declval<_Tp&>()))>
        -: 3578:{
        -: 3579:};
        -: 3580:
        -: 3581:template <class _Tp>
        -: 3582:struct __is_nothrow_swappable_imp<false, _Tp>
        -: 3583:    : public false_type
        -: 3584:{
        -: 3585:};
        -: 3586:
        -: 3587:template <class _Tp>
        -: 3588:struct __is_nothrow_swappable
        -: 3589:    : public __is_nothrow_swappable_imp<__is_swappable<_Tp>::value, _Tp>
        -: 3590:{
        -: 3591:};
        -: 3592:
        -: 3593:#else  // __has_feature(cxx_noexcept)
        -: 3594:
        -: 3595:template <class _Tp>
        -: 3596:struct __is_nothrow_swappable
        -: 3597:    : public false_type
        -: 3598:{
        -: 3599:};
        -: 3600:
        -: 3601:#endif  // __has_feature(cxx_noexcept)
        -: 3602:
        -: 3603:#ifdef _LIBCPP_UNDERLYING_TYPE
        -: 3604:
        -: 3605:template <class _Tp>
        -: 3606:struct underlying_type
        -: 3607:{
        -: 3608:    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;
        -: 3609:};
        -: 3610:
        -: 3611:#if _LIBCPP_STD_VER > 11
        -: 3612:template <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
        -: 3613:#endif
        -: 3614:
        -: 3615:#else  // _LIBCPP_UNDERLYING_TYPE
        -: 3616:
        -: 3617:template <class _Tp, bool _Support = false>
        -: 3618:struct underlying_type
        -: 3619:{
        -: 3620:    static_assert(_Support, "The underyling_type trait requires compiler "
        -: 3621:                            "support. Either no such support exists or "
        -: 3622:                            "libc++ does not know how to use it.");
        -: 3623:};
        -: 3624:
        -: 3625:#endif // _LIBCPP_UNDERLYING_TYPE
        -: 3626:
        -: 3627:#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE
        -: 3628:
        -: 3629:template <class _Tp>
        -: 3630:struct __has_operator_addressof_imp
        -: 3631:{
        -: 3632:    template <class>
        -: 3633:        static auto __test(__any) -> false_type;
        -: 3634:    template <class _Up>
        -: 3635:        static auto __test(_Up* __u)
        -: 3636:            -> typename __select_2nd<decltype(__u->operator&()), true_type>::type;
        -: 3637:
        -: 3638:    static const bool value = decltype(__test<_Tp>(nullptr))::value;
        -: 3639:};
        -: 3640:
        -: 3641:template <class _Tp>
        -: 3642:struct __has_operator_addressof
        -: 3643:    : public integral_constant<bool, __has_operator_addressof_imp<_Tp>::value>
        -: 3644:{};
        -: 3645:
        -: 3646:#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE
        -: 3647:
        -: 3648:_LIBCPP_END_NAMESPACE_STD
        -: 3649:
        -: 3650:#endif  // _LIBCPP_TYPE_TRAITS
